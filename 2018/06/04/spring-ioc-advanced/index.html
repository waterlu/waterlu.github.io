<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="个人技术博客"><title>Spring-IoC进阶 | Waterlu's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Spring-IoC进阶</h1><a id="logo" href="/.">Waterlu's Blog</a><p class="description">以铜为鉴，可正衣冠；以史为鉴，可知兴替；以人为鉴，可明得失。</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Spring-IoC进阶</h1><div class="post-meta">Jun 4, 2018<span> | </span><span class="category"><a href="/categories/Spring/">Spring</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><a class="disqus-comment-count" href="/2018/06/04/spring-ioc-advanced/#vcomment"><span class="valine-comment-count" data-xid="/2018/06/04/spring-ioc-advanced/"></span><span> 条评论</span></a><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#IoC使用进阶"><span class="toc-number">1.</span> <span class="toc-text">IoC使用进阶</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#FactoryBean"><span class="toc-number">1.1.</span> <span class="toc-text">FactoryBean</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ApplicationContextAware"><span class="toc-number">1.2.</span> <span class="toc-text">ApplicationContextAware</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BeanPostProcessor"><span class="toc-number">1.3.</span> <span class="toc-text">BeanPostProcessor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BeanFactoryPostProcessor"><span class="toc-number">1.4.</span> <span class="toc-text">BeanFactoryPostProcessor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BeanDefinitionRegistryPostProcessor"><span class="toc-number">1.5.</span> <span class="toc-text">BeanDefinitionRegistryPostProcessor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PostProcessor对比"><span class="toc-number">1.6.</span> <span class="toc-text">PostProcessor对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#参考"><span class="toc-number">1.7.</span> <span class="toc-text">参考</span></a></li></ol></li></ol></div></div><div class="post-content"><h2 id="IoC使用进阶"><a href="#IoC使用进阶" class="headerlink" title="IoC使用进阶"></a>IoC使用进阶</h2><p>本文讨论Spring IoC高级一点的用法，主要是一些深入定制化操作。</p>
<h3 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h3><p>我们之前的例子都是一个Bean对应一个对象，像下面这样</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"wheel"</span> <span class="attr">class</span>=<span class="string">"cn.lu.spring.ioc.Wheel"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>但是像Connection这样的对象，我们肯定希望是连接池模式，可是默认scope是<code>singleton</code> 只能使用一个连接，如果修改scop为 <code>prototype</code> 每次都创建一个新的连接，两者不能满足要求，那么如何创建对象池呢？</p>
<p>这个时候可以使用FactoryBean，通过FactoryBean的getOjbect()方法返回对象，进行对象池管理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.beans.factory;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FactoryBean</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// 返回对象</span></span><br><span class="line">  <span class="function">T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">  <span class="comment">// 返回对象类型</span></span><br><span class="line">  Class&lt;?&gt; getObjectType();</span><br><span class="line">  <span class="comment">// 是否单例</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义自己的Factory类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WheelFactory</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">Wheel</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Wheel <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 这里可以写自己的对象池逻辑</span></span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后修改xml配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"wheel"</span> <span class="attr">class</span>=<span class="string">"cn.lu.spring.ioc.WheelFactory"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>因为WheelFactory实现了FactoryBean接口，所以IoC容器不会返回WheelFactory类的实例对象，而是调用其getObject()方法返回真正的对象。</p>
<p>上面是通过XML配置FactoryBean，如何通过Java配置呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Config</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> WheelFactory <span class="title">wheelFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> WheelFactory();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义@Bean时返回WheelFactory，使用是正常@Autowired即可，实际返回Wheel对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Wheel wheel;</span><br></pre></td></tr></table></figure>
<h3 id="ApplicationContextAware"><a href="#ApplicationContextAware" class="headerlink" title="ApplicationContextAware"></a>ApplicationContextAware</h3><p>通常都是Spring自动帮我注入Bean对象，但有时我们也需要主动从IoC容器获取Bean对象，例如：查找声明了某个注解的Bean对象，这个时候就需要用到ApplicationContextAware了。实现ApplicationContextAware接口的setApplicationContext()方法就可以获得Spring的IoC容器（对应ApplicationContext类），我们看一下ApplicationContext类都提供了哪些方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.context;</span><br><span class="line"><span class="comment">// 这里省略了其他基类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationContext</span> <span class="keyword">extends</span> <span class="title">ListableBeanFactory</span> </span>&#123; </span><br><span class="line">  <span class="function">String <span class="title">getId</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">String <span class="title">getApplicationName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ApplicationContext类没啥干货，再看看基类ListableBeanFactory提供了哪些方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.beans.factory;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ListableBeanFactory</span> <span class="keyword">extends</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 检查容器中是否包含beanName这个Bean对象</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">containsBeanDefinition</span><span class="params">(String beanName)</span></span>;</span><br><span class="line">  <span class="comment">// 返回容器中定义的Bean的数量</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getBeanDefinitionCount</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">// 返回容器中定义的所有Bean的名字</span></span><br><span class="line">  String[] getBeanDefinitionNames();</span><br><span class="line">  <span class="comment">// 返回容器中所有type类型的Bean</span></span><br><span class="line">  &lt;T&gt; <span class="function">Map&lt;String, T&gt; <span class="title">getBeansOfType</span><span class="params">(Class&lt;T&gt; type)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">  <span class="comment">// 返回容器中所有含有annotationType注解的Bean</span></span><br><span class="line">  <span class="function">Map&lt;String, Object&gt; <span class="title">getBeansWithAnnotation</span><span class="params">(Class&lt;? extends Annotation&gt; annotationType)</span> </span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最常用的应该是getBeansOfType()和getBeansWithAnnotation()，根据类型或者注解获取Bean对象。</p>
<p>下面以解析自定义注解@RocketMQProduer为例说明ApplicationContextAware的用法：</p>
<ul>
<li>得到applicationContext后可以调用getBeansWithAnnotation()方法获取所有声明了RocketMQProducer注解的Bean对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MQProducerAutoConfiguration</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> ApplicationContext applicationContext;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.applicationContext = applicationContext;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@PostConstruct</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; beans = <span class="keyword">null</span>;</span><br><span class="line">    beans = applicationContext.getBeansWithAnnotation(RocketMQProducer.class);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a>BeanPostProcessor</h3><p>所有Bean对象初始化前后都会回调BeanPostProcessor接口，实现BeanPostProcessor接口可以做很多定制化工作，例如：解析自定义注解。 注意：BeanPostProcessor和InitializingBean不同，InitializingBean只会在实现类Bean创建以后回调，BeanPostProcessor则是在所有Bean创建以后都会回调，所以实现BeanPostProcessor接口相当于可以遍历所有创建的Bean对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.beans.factory.config;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Bean对象初始化之前执行</span></span><br><span class="line">  <span class="function">Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">  <span class="comment">// Bean对象初始化之后执行</span></span><br><span class="line">  <span class="function">Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>特别注意：BeanPostProcessor接口的两个方法不能返回null，否则后面就走不下去了，千万注意。</p>
</blockquote>
<p>执行顺序</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Constructor</span><br><span class="line">@PostConstruct</span><br><span class="line">afterPropertiesSet</span><br><span class="line">postProcessBeforeInitialization</span><br><span class="line">postProcessAfterInitialization</span><br></pre></td></tr></table></figure>
<p>下面仍然以解析自定义注解@RocketMQProduer为例说明BeanPostProcessor的用法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span></span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> </span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> </span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    Class clazz = bean.getClass();</span><br><span class="line">    <span class="comment">// 判断Bean对象是否声明了RocketMQProducer注解</span></span><br><span class="line">    <span class="keyword">if</span>(!clazz.isAnnotationPresent(RocketMQProducer.class)) &#123;</span><br><span class="line">      <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读取注解</span></span><br><span class="line">    RocketMQProducer annotation = (RocketMQProducer)clazz.getAnnotation(RocketMQProducer.class);</span><br><span class="line">    <span class="comment">// 获取注解上的属性</span></span><br><span class="line">    System.out.println(annotationTable.value());</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="BeanFactoryPostProcessor"><a href="#BeanFactoryPostProcessor" class="headerlink" title="BeanFactoryPostProcessor"></a>BeanFactoryPostProcessor</h3><p>BeanFactoryPostProcessor允许容器实例化Bean之前读取Bean的定义(配置元数据)，并可以修改它。典型的，<code>&lt;context:property-placeholder&gt;</code> 标签就是使用BeanFactoryPostProcessor的例子，读取Bean对象value中的<code>${db.username}</code> ，替换为从properties文件中读取到的真实值。<code>&lt;context:property-placeholder&gt;</code>  标签使用PropertyResourceConfigurer类实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.beans.factory.config;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertyResourceConfigurer</span> <span class="keyword">implements</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Properties mergedProps = mergeProperties();</span><br><span class="line">      <span class="comment">// Convert the merged properties, if necessary.</span></span><br><span class="line">      convertProperties(mergedProps);</span><br><span class="line">      <span class="comment">// Let the subclass process the properties.</span></span><br><span class="line">      processProperties(beanFactory, mergedProps);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanInitializationException(<span class="string">"Could not load properties"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>post()方法最重要是传入了ConfigurableListableBeanFactory参数，通过它可以读取到Bean的定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.beans.factory.config;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConfigurableListableBeanFactory</span> <span class="keyword">extends</span> <span class="title">ListableBeanFactory</span>, </span></span><br><span class="line"><span class="class">		<span class="title">AutowireCapableBeanFactory</span>, <span class="title">ConfigurableBeanFactory</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 读取BeanDefinition	          </span></span><br><span class="line">  <span class="function">BeanDefinition <span class="title">getBeanDefinition</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="BeanDefinitionRegistryPostProcessor"><a href="#BeanDefinitionRegistryPostProcessor" class="headerlink" title="BeanDefinitionRegistryPostProcessor"></a>BeanDefinitionRegistryPostProcessor</h3><p>这个接口给了我们在Spring容器构造完所有Bean对象后对其进行修改的可能，Mybatis的动态代理就是基于BeanDefinitionRegistryPostProcessor实现的。</p>
<p>下面通过一个例子说明它的用法。</p>
<p>我们定义@Car注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Car &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们定义接口ICar和它的实现类Benz、Audi</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Car</span>(<span class="string">"Benz"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ICar</span> </span>&#123;</span><br><span class="line">  <span class="function">String <span class="title">getBrand</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Benz</span> <span class="keyword">implements</span> <span class="title">ICar</span> </span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> String brand = <span class="string">"Benz"</span>;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getBrand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> brand;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Audi</span> <span class="keyword">implements</span> <span class="title">ICar</span> </span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> String brand = <span class="string">"Audi"</span>;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getBrand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> brand;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们希望注入ICar时，通过@Car注解的value属性来确定创建那个实体类对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">ICar car;</span><br></pre></td></tr></table></figure>
<p>由于<code>@Car(&quot;Benz&quot;)</code> ，所以这里car变量注入Benz类实例对象。</p>
<p>我们先来分析一下如何实现，然后再来看代码：</p>
<ul>
<li>我们在Spring容器完成Bean创建后，扫描@Car注解，手动将正确的Bean对象加入到容器中；</li>
<li>加入到容器中的Bean对象的类型是ICar，实体类对象是Benz或者Audi；</li>
<li>这里我们用FactoryBean来返回ICar对象。</li>
</ul>
<p>先看如何扫描注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanDefinitionRegistry</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionRegistryPostProcessor</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String RESOURCE_PATTERN = <span class="string">"/**/*.class"</span>;</span><br><span class="line">  <span class="keyword">private</span> ResourcePatternResolver resolver = <span class="keyword">new</span> PathMatchingResourcePatternResolver();</span><br><span class="line">  CarFactoryBean carFactoryBean = <span class="keyword">new</span> CarFactoryBean();	</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> </span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="comment">// 去哪个目录扫描注解</span></span><br><span class="line">    String basePackageName = <span class="string">"cn.lu.spring.ioc.post.registry"</span>;</span><br><span class="line">    String basePackage = ClassUtils.convertClassNameToResourcePath(basePackageName);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      String pattern = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX + </span><br><span class="line">        basePackage + RESOURCE_PATTERN;</span><br><span class="line">      <span class="comment">// 读取资源文件（.class文件）</span></span><br><span class="line">      Resource[] resources = resolver.getResources(pattern);      </span><br><span class="line">      MetadataReaderFactory readerFactory = <span class="keyword">new</span> CachingMetadataReaderFactory(resolver);</span><br><span class="line">      <span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">        <span class="comment">// 遍历包下的每一个.class文件</span></span><br><span class="line">        <span class="keyword">if</span> (resource.isReadable()) &#123;</span><br><span class="line">          <span class="comment">// 解析.class文件</span></span><br><span class="line">          MetadataReader reader = readerFactory.getMetadataReader(resource);          </span><br><span class="line">          <span class="keyword">for</span> (String annotationType : reader.getAnnotationMetadata().getAnnotationTypes()) &#123;</span><br><span class="line">            <span class="comment">// 查找@Car注解</span></span><br><span class="line">            <span class="keyword">if</span> (!annotationType.equalsIgnoreCase(Car.class.getName())) &#123;</span><br><span class="line">              <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 构造Bean定义BeanDefinition</span></span><br><span class="line">            ScannedGenericBeanDefinition definition = <span class="keyword">new</span> ScannedGenericBeanDefinition(reader);</span><br><span class="line">            <span class="comment">// beanName是ICar，Bean对象的类型是Interface，实体是FactoryBean</span></span><br><span class="line">            String shortClassName = ClassUtils.getShortName(definition.getBeanClassName());</span><br><span class="line">            String beanName = Introspector.decapitalize(shortClassName);</span><br><span class="line">            <span class="comment">// 定义&lt;bean&gt;的class为CarFactoryBean</span></span><br><span class="line">            definition.setBeanClass(carFactoryBean.getClass());</span><br><span class="line">            <span class="comment">// 读取@Car注解的所有属性</span></span><br><span class="line">            Map&lt;String, Object&gt; properties = reader.getAnnotationMetadata()</span><br><span class="line">              .getAnnotationAttributes(annotationType);</span><br><span class="line">            <span class="comment">// 根据@Car注解的value属性为CarFactoryBean添加brand属性</span></span><br><span class="line">            definition.getPropertyValues().add(<span class="string">"brand"</span>, properties.get(<span class="string">"value"</span>));</span><br><span class="line">            definition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE);</span><br><span class="line">            BeanDefinitionHolder holder = <span class="keyword">new</span> BeanDefinitionHolder(definition,beanName);</span><br><span class="line">            <span class="comment">// 将我们手动创建的Bean加入到容器中</span></span><br><span class="line">            BeanDefinitionReaderUtils.registerBeanDefinition(holder, registry);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>几个要点：</p>
<ul>
<li>postProcessBeanDefinitionRegistry()是入口</li>
<li>使用PathMatchingResourcePatternResolver读取.class文件</li>
<li>使用MetadataReader解析.class文件</li>
<li>创建BeanDefinition就是手动定义一个Bean的信息</li>
<li>setBeanClass()为FactoryBean把接口改为了实体类，如果不修改Spring会尝试创建ICar对象，会报错</li>
<li>最后registerBeanDefinition()把手工定义的Bean加入到容器中</li>
</ul>
<p>FactoryBean就比较简单了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarFactoryBean</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">Car</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> String brand;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Car <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (brand.equalsIgnoreCase(<span class="string">"Benz"</span>)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Benz();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (brand.equalsIgnoreCase(<span class="string">"Audi"</span>)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Audi();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Car(<span class="string">"Unknown"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="PostProcessor对比"><a href="#PostProcessor对比" class="headerlink" title="PostProcessor对比"></a>PostProcessor对比</h3><ul>
<li>InitializingBean，每个对象实例化完成后执行该对象的afterPropertiesSet()方法，每个对象执行自己的方法，互不影响，无参数传入；一般我们可以在这个时间点做初始化操作。</li>
<li>BeanPostProcessor，所有对象初始化前后都会执行同一个postProcessAfterInitialization()方法，每个对象执行的都是同一个对象的方法，出入参数为Bean对象本身；一般我们可以在这个时间点对Bean的特殊属性做特殊处理，例如自定义注解。通过修改返回值，实际上可以返回另外一个Bean对象。</li>
<li>BeanFactoryPostProcessor，每个对象实例化前执行，可以读取到bean的配置元数据，并进行修改；</li>
<li>BeanDefinitionRegistryPostProcessor，在IoC容器完成Bean初始化之后执行，我们可以在此时加入其他Bean对象到IoC容器中。</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.jianshu.com/p/1417eefd2ab1" target="_blank" rel="noopener">Spring探秘|妙用BeanPostProcessor</a></p>
</div><div class="tags"><a href="/tags/Spring/">Spring</a><a href="/tags/IoC/">IoC</a></div><div class="post-nav"><a class="pre" href="/2018/06/05/spring-ioc-inside/">Spring-IoC原理</a><a class="next" href="/2018/05/31/mybatis-aop/">Mybatis动态代理原理</a></div><div id="vcomment"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script><script>var notify = 'false' == true ? true : false;
var verify = 'false' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'5mrT8f80zgJVcJvIPrSGzFjV-gzGzoHsz',
  appKey:'Db9rWWROewfegKQJkbYncKt1',
  placeholder:'请在这里留下你要说的话',
  avatar:'mm',
  guest_info:guest_info,
  pageSize:'10'
})</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JAVA/">JAVA</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/WEB/">WEB</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/分布式/">分布式</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/工具/">工具</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/并发编程/">并发编程</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/消息队列/">消息队列</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/">设计模式</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/hashCode/" style="font-size: 15px;">hashCode</a> <a href="/tags/mq/" style="font-size: 15px;">mq</a> <a href="/tags/并发/" style="font-size: 15px;">并发</a> <a href="/tags/线程/" style="font-size: 15px;">线程</a> <a href="/tags/线程池/" style="font-size: 15px;">线程池</a> <a href="/tags/任务调度/" style="font-size: 15px;">任务调度</a> <a href="/tags/排队策略/" style="font-size: 15px;">排队策略</a> <a href="/tags/饱和策略/" style="font-size: 15px;">饱和策略</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/github/" style="font-size: 15px;">github</a> <a href="/tags/多线程/" style="font-size: 15px;">多线程</a> <a href="/tags/synchronized/" style="font-size: 15px;">synchronized</a> <a href="/tags/wait/" style="font-size: 15px;">wait</a> <a href="/tags/notify/" style="font-size: 15px;">notify</a> <a href="/tags/单例/" style="font-size: 15px;">单例</a> <a href="/tags/线程安全/" style="font-size: 15px;">线程安全</a> <a href="/tags/Database/" style="font-size: 15px;">Database</a> <a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/Sharding/" style="font-size: 15px;">Sharding</a> <a href="/tags/分布式/" style="font-size: 15px;">分布式</a> <a href="/tags/SnowFlake/" style="font-size: 15px;">SnowFlake</a> <a href="/tags/索引/" style="font-size: 15px;">索引</a> <a href="/tags/mybatis/" style="font-size: 15px;">mybatis</a> <a href="/tags/WEB/" style="font-size: 15px;">WEB</a> <a href="/tags/短地址/" style="font-size: 15px;">短地址</a> <a href="/tags/哈希/" style="font-size: 15px;">哈希</a> <a href="/tags/rocketmq/" style="font-size: 15px;">rocketmq</a> <a href="/tags/springboot/" style="font-size: 15px;">springboot</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/Hashmap/" style="font-size: 15px;">Hashmap</a> <a href="/tags/哈希冲突/" style="font-size: 15px;">哈希冲突</a> <a href="/tags/SpringBoot/" style="font-size: 15px;">SpringBoot</a> <a href="/tags/热部署/" style="font-size: 15px;">热部署</a> <a href="/tags/Reentrantlock/" style="font-size: 15px;">Reentrantlock</a> <a href="/tags/内存模型/" style="font-size: 15px;">内存模型</a> <a href="/tags/内存可见性/" style="font-size: 15px;">内存可见性</a> <a href="/tags/指令重排序/" style="font-size: 15px;">指令重排序</a> <a href="/tags/ConcurrentHashMap/" style="font-size: 15px;">ConcurrentHashMap</a> <a href="/tags/注解/" style="font-size: 15px;">注解</a> <a href="/tags/Spring/" style="font-size: 15px;">Spring</a> <a href="/tags/AOP/" style="font-size: 15px;">AOP</a> <a href="/tags/动态代理/" style="font-size: 15px;">动态代理</a> <a href="/tags/IoC/" style="font-size: 15px;">IoC</a> <a href="/tags/Spring-Cloud/" style="font-size: 15px;">Spring Cloud</a> <a href="/tags/Eureka/" style="font-size: 15px;">Eureka</a> <a href="/tags/服务治理/" style="font-size: 15px;">服务治理</a> <a href="/tags/反射/" style="font-size: 15px;">反射</a> <a href="/tags/Ribbon/" style="font-size: 15px;">Ribbon</a> <a href="/tags/泛型/" style="font-size: 15px;">泛型</a> <a href="/tags/Mybatis/" style="font-size: 15px;">Mybatis</a> <a href="/tags/InnoDB/" style="font-size: 15px;">InnoDB</a> <a href="/tags/Git/" style="font-size: 15px;">Git</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/08/27/algorithm-basic/">算法-常见算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/09/notebook-mysql-inside-innodb-engine/">读书笔记-MySQL技术内幕（1）</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/08/tool-gitflow/">GitFlow</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/07/springcloud-ribbon/">Spring Cloud - Ribbon</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/06/springcloud-eureka/">Spring Cloud - Eureka</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/05/spring-ioc-inside/">Spring-IoC原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/spring-ioc-advanced/">Spring-IoC进阶</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/31/mybatis-aop/">Mybatis动态代理原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/29/java-basic-generic/">Java基础-泛型</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/28/java-basic-proxy/">Java基础-动态代理</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://github.com/waterlu" title="waterlu's github" target="_blank">waterlu's github</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">Waterlu's Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>