<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="个人技术博客"><title>HashMap源码分析 | Waterlu's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">HashMap源码分析</h1><a id="logo" href="/.">Waterlu's Blog</a><p class="description">以铜为鉴，可正衣冠；以史为鉴，可知兴替；以人为鉴，可明得失。</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">HashMap源码分析</h1><div class="post-meta">May 8, 2018<span> | </span><span class="category"><a href="/categories/JAVA/">JAVA</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap解析"><span class="toc-number">1.</span> <span class="toc-text">HashMap解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基本用法"><span class="toc-number">1.1.</span> <span class="toc-text">基本用法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Map接口"><span class="toc-number">1.1.1.</span> <span class="toc-text">Map接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Map遍历"><span class="toc-number">1.1.2.</span> <span class="toc-text">Map遍历</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#源码分析"><span class="toc-number">1.2.</span> <span class="toc-text">源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#数据结构"><span class="toc-number">1.2.1.</span> <span class="toc-text">数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PUT流程"><span class="toc-number">1.2.2.</span> <span class="toc-text">PUT流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PUT源码"><span class="toc-number">1.2.3.</span> <span class="toc-text">PUT源码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#扩容优化"><span class="toc-number">1.2.4.</span> <span class="toc-text">扩容优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#红黑树"><span class="toc-number">1.2.5.</span> <span class="toc-text">红黑树</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#死循环"><span class="toc-number">1.3.</span> <span class="toc-text">死循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Debug"><span class="toc-number">1.4.</span> <span class="toc-text">Debug</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#参考"><span class="toc-number">1.5.</span> <span class="toc-text">参考</span></a></li></ol></li></ol></div></div><div class="post-content"><h2 id="HashMap解析"><a href="#HashMap解析" class="headerlink" title="HashMap解析"></a>HashMap解析</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>分析HashMap源码前，先看看怎么使用。</p>
<h4 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h4><p>首先看一下Map接口，Map接口里面定义了常用的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// 大小</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">// 是否包含key</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span></span>;</span><br><span class="line">  <span class="comment">// 读</span></span><br><span class="line">  <span class="function">V <span class="title">get</span><span class="params">(Object key)</span></span>;</span><br><span class="line">  <span class="comment">// 写</span></span><br><span class="line">  <span class="function">V <span class="title">put</span><span class="params">(K key, V value)</span></span>;</span><br><span class="line">  <span class="comment">// 删除</span></span><br><span class="line">  <span class="function">V <span class="title">remove</span><span class="params">(Object key)</span></span>;</span><br><span class="line">  <span class="comment">// 返回所有key</span></span><br><span class="line">  <span class="function">Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">// 返回所有value</span></span><br><span class="line">  <span class="function">Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">// 遍历</span></span><br><span class="line">  Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet();</span><br><span class="line">  <span class="comment">// 内部类</span></span><br><span class="line">  <span class="class"><span class="keyword">interface</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 遍历读取key</span></span><br><span class="line">    <span class="function">K <span class="title">getKey</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 遍历读取value</span></span><br><span class="line">    <span class="function">V <span class="title">getValue</span><span class="params">()</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Map遍历"><a href="#Map遍历" class="headerlink" title="Map遍历"></a>Map遍历</h4><p>方法一，我认为最正统的写法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(Map.Entry&lt;String, Object&gt; entry : map.entrySet()) &#123;</span><br><span class="line">  String key = entry.getKey();</span><br><span class="line">  Object value = entry.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法二，意思和上面的方法是一样的，看上去绕一些</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator it = map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">  Map.Entry&lt;String, Object&gt; entry = (Map.Entry&lt;String, Object&gt;)it.next();</span><br><span class="line">  String key = entry.getKey();</span><br><span class="line">  Object value = entry.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法三，先拿到key，再通过get()方法读取value，绕了一圈</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(String key : map.keySet()) &#123;</span><br><span class="line">  Object value = map.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法四，只能获取value，得不到key</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(Object value : map.values()) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>基于JDK1.8的源码进行分析。</p>
<h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>先上源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// 默认容量16</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line">  <span class="comment">// 默认加载因子3/4,当容量到达12时开始扩容</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line">  <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line">  <span class="comment">// 大小</span></span><br><span class="line">  <span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line">  <span class="comment">// 下一个需要扩容的阈值</span></span><br><span class="line">  <span class="keyword">int</span> threshold;</span><br><span class="line">  <span class="comment">// 数据存储，是一个数组，数组的大小就是容量</span></span><br><span class="line">  <span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line">  <span class="comment">// 加载因子,默认3/4</span></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line">  <span class="comment">// 红黑树转换</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>table：数组，保存数据；</p>
<p>threshold：阈值，当数组中的数据达到这个值以后，对数组进行扩容；</p>
<p><img src="/images/java-basic-hashmap-data.png" alt=""></p>
<p>HashMap采用了链地址法来解决冲突问题，简单说，就是数组加链表的结合。在每个数组元素上都一个链表结构，当数据被Hash后，得到数组下标，把数据放在对应下标元素的链表上。</p>
<p>如上图所示，HashMap的基本存储结构是一个数组，根据key的hash值取模可以定位到数组的某一个元素，如果有多个key定位到同一个元素，通过链表连接(p1-&gt;next=p2)。读取数据时先根据key的hash值定位到元素，然后再遍历链表查找。如果分布不均匀导致某一个链表很长，就会降低效率。或者说，HashMap的容量间接决定了它的效率：当容量大时，每个key容易落到不同的数组位置上，一次就能读取到；当容量小时，多个key容易发生哈希碰撞，就需要遍历链表，效率自然就降低了。当然，大容量就占用了空间，还是典型的空间换时间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">  <span class="keyword">final</span> K key;</span><br><span class="line">  V value;</span><br><span class="line">  Node&lt;K,V&gt; next;</span><br><span class="line">  Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">    <span class="keyword">this</span>.hash = hash;</span><br><span class="line">    <span class="keyword">this</span>.key = key;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">    <span class="keyword">this</span>.next = next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Node是真实存储键值对的数据结构：Node是HashMap的内部类，实现了Map.Entry接口，其中hash是key的原始哈希值，当扩容时需要用它重新计算数组下标位置，next指向下一个元素，默认为null，也就是说Node可以组成一个链表。</p>
<h4 id="PUT流程"><a href="#PUT流程" class="headerlink" title="PUT流程"></a>PUT流程</h4><p>先看一下我总结的PUT操作流程，再看源码</p>
<div id="flowchart-0" class="flow-chart"></div>

<p>GET操作流程</p>
<h4 id="PUT源码"><a href="#PUT源码" class="headerlink" title="PUT源码"></a>PUT源码</h4><p>第一步，计算哈希值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> h;</span><br><span class="line">  <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先需要计算key的哈希值</p>
<ul>
<li>调用hashCode()方法获取对象的int型哈希值；</li>
<li><code>&gt;&gt;&gt; 16</code> 意思是无符号右移16位；</li>
<li><code>^</code> 意思是异或操作，两位相同为0，不同为1（异或可以实现两数交换）；</li>
<li>高16位与0做异或，高位值不变；低16位与高16位做异或，混合高16位和低16位信息（称为扰动）；</li>
</ul>
<p>为什么要异或（或者为什么要扰动）？</p>
<ul>
<li>我们知道hashCode()方法的返回值是int，范围是很大的，如果直接以这个返回值作为数组下标显然内存是不够用的，所以会采用类似取模的办法；</li>
<li>我们知道默认的数组大小是16，那么就是对16取模，相当于hashCode()返回值中只有最后4位起了作用，其他位都没有起到作用；即使int数比较分散，但是最后四位可能碰撞严重；换句话说，精心设计了哈希算法，计算出了分散的32位整数，但实际上只有最后4位起作用，效果可能还不好；</li>
<li>所以在JDK1.7中是这么做的，进行了多次扰动；（让高位与最后四位进行异或运算）</li>
</ul>
<blockquote>
<p>h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);</p>
<p>return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);</p>
</blockquote>
<ul>
<li>JDK1.8认为四次扰动不必要，一次就够了，所以拿高16位与低16位进行异或计算；</li>
<li>我理解：如果数组大小为16，那么实际上是[0,4)和[16,20)位上的值决定了数组下标位置，其他位的计算是没有用的；当然，数组大小是可以扩容的，如果扩容到64，那么起作用的就是[0,6)和[16,22)位了。</li>
</ul>
<p><img src="/images/java-batis-hashmap-hashcode.jpg" alt=""></p>
<p>上图充分说明了哈希和取模的过程。</p>
<blockquote>
<p>如果容量选择31这样的质数，hash冲突就会小很多，但是取模计算和扩容就复杂了。HashMap才用16这样的非质数容量，必然导致冲突比31这样的质数多，中庸之道就是通过异或运算进行扰动综合。</p>
</blockquote>
<p>第二步，取模</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>) &#123;</span><br><span class="line">  tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>i = (n - 1) &amp; hash，假设n=16，那么&amp;15就相当于&amp;00001111，也就是保留hash的后四位的意思。</p>
<p>p=tab[i]就是根据key的hash值最终计算出来数组下标位置。</p>
<p>如果这个位置上的元素是空的，直接创建Node对象放到这里即可。</p>
<blockquote>
<p>当n为2的x次方时，&amp; (n-1)操作就起到了取模的作用，这就是为什么HashMap的容量总是2的x次方的原因。如果不是，那么%取模操作效率是很低的。</p>
</blockquote>
<p>第三步，元素链表</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>) &#123;</span><br><span class="line">  tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  Node&lt;K,V&gt; e; K k;</span><br><span class="line">  <span class="keyword">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">    <span class="comment">// 如果当前元素hash值和key的hash值一样，直接返回e</span></span><br><span class="line">    e = p;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode) &#123;</span><br><span class="line">    <span class="comment">// 红黑树特殊处理</span></span><br><span class="line">    e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 遍历链表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">      <span class="comment">// 找到链表最后一个元素</span></span><br><span class="line">      <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 新数据加入到链表末尾</span></span><br><span class="line">        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">          <span class="comment">// 当元素个数达到8个时，转换为红黑树存储</span></span><br><span class="line">          treeifyBin(tab, hash);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 链表里某个元素hash值和key的hash值一样，直接返回e</span></span><br><span class="line">      <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      p = e;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果元素已经存在（hash值存在），直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">    V oldValue = e.value;</span><br><span class="line">    <span class="comment">// 返回的一定是旧值，是否替换为新值需要onlyIfAbsent=false，默认false替换</span></span><br><span class="line">    <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">      e.value = value;</span><br><span class="line">    afterNodeAccess(e);</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定位到数组位置后，遍历链表查找key是否存在，如果key存在直接返回value，不存在把新元素加入到链表末尾。</p>
<p>如果key存在，返回值一定是旧的value，至于是否使用新value替换旧value可以设置，默认是替换的。</p>
<p>put()方法是有返回值的，如果返回null不是说put()操作失败了，说明key不存在；如果返回值不为空，说明key存在，没有写入新数据，直接返回了存在的value。</p>
<p>key可以是null的，定位到数组0位置，但key是唯一的，所以只能有一个null的key。</p>
<p>比较key的时候是根据hash值进行比较的，所以使用String做key感觉比使用Object做key更放心一些。</p>
<p>第四步，扩容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 简化代码</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">  <span class="comment">// 旧数据</span></span><br><span class="line">  Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">  <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">  <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">  <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;  </span><br><span class="line">  <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 扩容一倍</span></span><br><span class="line">    newCap = oldCap &lt;&lt; <span class="number">1</span>;      </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 使用默认值初始化</span></span><br><span class="line">    newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">    newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 重新计算阈值=容量*因子</span></span><br><span class="line">    newThr = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">  &#125;</span><br><span class="line">  threshold = newThr;</span><br><span class="line">  <span class="comment">// 扩容后的新数据</span></span><br><span class="line">  Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">  table = newTab;</span><br><span class="line">  <span class="comment">// 数据迁移</span></span><br><span class="line">  <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 遍历旧数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">      Node&lt;K,V&gt; e;</span><br><span class="line">      <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (e.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 只有一个元素，直接复制，根据key的原始哈希值重新计算数组下标</span></span><br><span class="line">          newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode) &#123;</span><br><span class="line">          <span class="comment">// 红黑树特殊处理 </span></span><br><span class="line">          ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">          <span class="comment">// 链表情况</span></span><br><span class="line">          Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">          Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">          Node&lt;K,V&gt; next;</span><br><span class="line">          <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 遍历链表</span></span><br><span class="line">            next = e.next;</span><br><span class="line">            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="comment">// 位置不变</span></span><br><span class="line">              <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                loHead = e;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// 顺序不变</span></span><br><span class="line">                loTail.next = e;</span><br><span class="line">              loTail = e;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// 位置+oldCap</span></span><br><span class="line">              <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                hiHead = e;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// 顺序不变</span></span><br><span class="line">                hiTail.next = e;</span><br><span class="line">              hiTail = e;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">          <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">            loTail.next = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 低位链表</span></span><br><span class="line">            newTab[j] = loHead;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">            hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 高位链表</span></span><br><span class="line">            newTab[j + oldCap] = hiHead;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newTab;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="扩容优化"><a href="#扩容优化" class="headerlink" title="扩容优化"></a>扩容优化</h4><p>这部分代码是JDK1.8优化过的，需要解释一下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap(<span class="number">4</span>);</span><br><span class="line">map.put(<span class="string">"A"</span>, <span class="number">90</span>);</span><br><span class="line">map.put(<span class="string">"E"</span>, <span class="number">85</span>);</span><br><span class="line">map.put(<span class="string">"I"</span>, <span class="number">80</span>);</span><br><span class="line">map.put(<span class="string">"M"</span>, <span class="number">70</span>);</span><br></pre></td></tr></table></figure>
<p>我们通过上面的实际例子来说明。为了简单，初始化容量为4，默认因子0.75，阈值为3。当put(“M”)时容量超过阈值，启动扩容操作。</p>
<p>扩容从4增加到8，我们看一下数组下标计算的变化：</p>
<p>hash(A)=01000001,  hash(E)=01000101, hash(I)=01001001, hash(M)=01001101</p>
<p>容量为4的情况，截取最后两位，AEIM的最后两位都是01，对应的数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">01000001</span>&amp;<span class="number">0011</span>=<span class="number">01</span>, <span class="number">01000101</span>&amp;<span class="number">0011</span>=<span class="number">01</span>, <span class="number">01001001</span>&amp;<span class="number">0011</span>=<span class="number">01</span>, <span class="number">01001101</span>&amp;<span class="number">0011</span>=<span class="number">01</span></span><br></pre></td></tr></table></figure>
<p>容量为8的情况，截取最后三位，AI的最后三位是001，EM的最后三位是101</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">01000001</span>&amp;<span class="number">0111</span>=<span class="number">001</span>, <span class="number">01000101</span>&amp;<span class="number">0111</span>=<span class="number">101</span>, <span class="number">01001001</span>&amp;<span class="number">0111</span>=<span class="number">001</span>, <span class="number">01001101</span>&amp;<span class="number">0111</span>=<span class="number">101</span></span><br></pre></td></tr></table></figure>
<p>以上，可以看出：扩容以后，由于只是多截取了一位，所以数组下标或者不变，或者增加4（旧容量）。</p>
<p>因此，扩容时就不需要重新计算链表中每一个元素的新位置，要么不变，要么增加旧容量，所以才有了上面的算法：设立两个指针，loHead指向位置不变的，hiHead指向增加4的。了解了原理以后，我们再来看代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>注意，oldCap第一位是1，其他位都是0，所以&amp; oldCap相当于判断hash值中新增加的哪一位的值。例如：继续上面的例子oldCap=100，hash(A)=01000001，01000001&amp;100=0，其实就是在判断hash(A)的倒数第三位的值。我们知道原来只截取后两位，倒数第三位就新增的截取位。如果这一位等于0，数组下标就不变，如果这一位等于1，数组下标就加4。</p>
<p>所以，当(e.hash &amp; oldCap) == 0时，将元素添加到loHead链表中，== 1时，将元素添加到hiHead链表中。</p>
<p>这样，遍历完旧数据后，就根据倒数第三位的值把就数据分为两份：loHead和hiHead，最后把它们放到数组中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">newTab[j] = loHead;</span><br><span class="line">newTab[j + oldCap] = hiHead;</span><br></pre></td></tr></table></figure>
<h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><p>注意到put()代码里面有对TreeNode的特殊处理，这是JDK1.8新增加的红黑树。当链表很长时，遍历链表必然降低效率，所以当链表中元素个数超过8个时，不再使用链表，而改为使用红黑树存储，这样在get()时可以提高效率。</p>
<h3 id="死循环"><a href="#死循环" class="headerlink" title="死循环"></a>死循环</h3><p>HashMap是线程不安全的，下面来具体分析一下多线程put()操作引起的get()方法死循环问题。</p>
<p>这个问题也可以描述成HashMap引发的CPU 100%问题，查看堆栈程序都Hang在HashMap.get()这个方法上，因为get()出现死循环，所以一直占用CPU。</p>
<p>首先，死循环的原因一定是链表出了问题，出现了循环链表。如果多线程并发put()操作出了问题，导致出现了循环列表，那么当get()查询到这个链表时，就会进入死循环出不来。</p>
<p>原理清楚了，下面看看具体的实例。</p>
<blockquote>
<p> 注意，例子是基于JDK1.7的，因为JDK1.7及以下才有这个问题。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">  Entry[] oldTable = table;</span><br><span class="line">  <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">  <span class="comment">// 创建一个新的Hash表</span></span><br><span class="line">  Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">  <span class="comment">// 数据迁移</span></span><br><span class="line">  transfer(newTable);</span><br><span class="line">  table = newTable;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">  <span class="comment">// 遍历旧数据</span></span><br><span class="line">  <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">      Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">      <span class="comment">// 重新计算新容量下的数组下标</span></span><br><span class="line">      <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">      e.next = newTable[i];</span><br><span class="line">      newTable[i] = e;</span><br><span class="line">      e = next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>JDK1.8保持了链表的顺序不变，所以不会出现循环链表的情况了，也就不会出现死循环了。虽然不会出现死循环了，但是还有可能出现其他问题，所以仍然不是线程安全的，在多线程环境下不建议使用。</p>
</blockquote>
<p><img src="/images/java-basic-hashmap-deadloop-1.jpg" alt=""></p>
<p>首先来看单线程的情况：</p>
<p>旧数据容量2，key的哈希值是3、7、5，都存储在table[1]，新数据容量4，table[1]=5，table[3]=3、7；</p>
<p>数据迁移算法：遍历全部旧数据，将其从旧链表中摘下，插入到新链表的最前面。</p>
<p>接下来考虑多线程的情况，假设两个线程A和B，A线程执行到<code>next = e.next;</code> 时被挂起，B线程一直执行完成，那么当前状态如下：粉色表示线程A、天蓝色表示线程B。</p>
<p><img src="/images/java-basic-hashmap-deadloop-2.jpg" alt=""></p>
<p>接下来线程A继续执行，当前e=3,next=7。将3插入到table[3]开头，然后，e=next=7。</p>
<p><img src="/images/java-basic-hashmap-deadloop-3.jpg" alt=""></p>
<p>下一个循环，e=7，next=3，将7插入到table[3]开头，然后e=next=3。</p>
<p><img src="/images/java-basic-hashmap-deadloop-4.jpg" alt=""></p>
<p>下一个循环，e=3，next=null，将3插入到table[3]开头，e=next=null。循环结束，最后的结果如下，形成了循环链表。</p>
<p><img src="/images/java-basic-hashmap-deadloop-5.jpg" alt=""></p>
<p>此时，如果线程A调用get(11)就会进入无限循环，问题重现。</p>
<h3 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h3><p>默认debug时是不能调试JDK源码的，具体体现就是单步执行和加断点失败，为了调试JDK源码需要修改配置：</p>
<p>Setting –&gt; Build,Execution,Deployment –&gt; Debugger –&gt; Stepping </p>
<p>把Do not step into the classes中的<code>java.*</code> 和<code>javax.*</code> 取消勾选</p>
<p><img src="/images/java-basic-hashmap-debug.png" alt=""></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.zhihu.com/question/20733617" target="_blank" rel="noopener">JDK 源码中 HashMap 的 hash 方法原理是什么？</a></p>
<p><a href="http://www.cnblogs.com/ITtangtang/p/3948406.html" target="_blank" rel="noopener">Java集合：HashMap源码剖析</a></p>
<p><a href="http://www.importnew.com/20386.html" target="_blank" rel="noopener">Java8系列之重新认识HashMap</a></p>
<p><a href="https://coolshell.cn/articles/9606.html" target="_blank" rel="noopener">疫苗：Java HashMap的死循环</a></p>
<p><a href="https://blog.csdn.net/UzV80PX5V412NE/article/details/78591134" target="_blank" rel="noopener">漫画：什么是HashMap？</a></p>
<p><a href="https://blog.csdn.net/minkeyto/article/details/78667944" target="_blank" rel="noopener">漫画：高并发下的HashMap</a></p>
<p><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">s=>start: 开始
hash=>operation: 计算key的哈希值
table=>condition: 数组是否为空?
init=>operation: 初始化数组(16)
mod=>operation: 去模计算数组下标
node=>condition: 下标位置元素是否为空?
newNode=>operation: 创建Node对象放入数组
nodeLink=>operation: 遍历链表到末尾
newLinkNode=>operation: 创建Node对象加入链表末尾
addSize=>operation: 增加容量
size=>condition: 容量达到阈值？
resize=>operation: 扩容
e=>end: 结束

s->hash->table
table(yes)->init->mod
table(no)->mod
mod->node
node(yes)->newNode
node(no)->nodeLink->newLinkNode
newNode->addSize
newLinkNode->addSize
addSize->size
size(yes)->resize
size(no)->e
resize->e</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12,"theme":"simple"}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script></p>
</div><div class="tags"><a href="/tags/JAVA/">JAVA</a><a href="/tags/Hashmap/">Hashmap</a><a href="/tags/哈希冲突/">哈希冲突</a></div><div class="post-nav"><a class="next" href="/2018/05/07/database-theory/">数据库原理</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JAVA/">JAVA</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/WEB/">WEB</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/分布式/">分布式</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/工具/">工具</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/并发编程/">并发编程</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/消息队列/">消息队列</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/">设计模式</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/内存模型/" style="font-size: 15px;">内存模型</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/mq/" style="font-size: 15px;">mq</a> <a href="/tags/rocketmq/" style="font-size: 15px;">rocketmq</a> <a href="/tags/并发/" style="font-size: 15px;">并发</a> <a href="/tags/线程/" style="font-size: 15px;">线程</a> <a href="/tags/线程池/" style="font-size: 15px;">线程池</a> <a href="/tags/排队策略/" style="font-size: 15px;">排队策略</a> <a href="/tags/饱和策略/" style="font-size: 15px;">饱和策略</a> <a href="/tags/多线程/" style="font-size: 15px;">多线程</a> <a href="/tags/单例/" style="font-size: 15px;">单例</a> <a href="/tags/线程安全/" style="font-size: 15px;">线程安全</a> <a href="/tags/任务调度/" style="font-size: 15px;">任务调度</a> <a href="/tags/synchronized/" style="font-size: 15px;">synchronized</a> <a href="/tags/wait/" style="font-size: 15px;">wait</a> <a href="/tags/notify/" style="font-size: 15px;">notify</a> <a href="/tags/github/" style="font-size: 15px;">github</a> <a href="/tags/内存可见性/" style="font-size: 15px;">内存可见性</a> <a href="/tags/指令重排序/" style="font-size: 15px;">指令重排序</a> <a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/WEB/" style="font-size: 15px;">WEB</a> <a href="/tags/短地址/" style="font-size: 15px;">短地址</a> <a href="/tags/哈希/" style="font-size: 15px;">哈希</a> <a href="/tags/hashCode/" style="font-size: 15px;">hashCode</a> <a href="/tags/JAVA/" style="font-size: 15px;">JAVA</a> <a href="/tags/Hashmap/" style="font-size: 15px;">Hashmap</a> <a href="/tags/哈希冲突/" style="font-size: 15px;">哈希冲突</a> <a href="/tags/Database/" style="font-size: 15px;">Database</a> <a href="/tags/Sharding/" style="font-size: 15px;">Sharding</a> <a href="/tags/分布式/" style="font-size: 15px;">分布式</a> <a href="/tags/SnowFlake/" style="font-size: 15px;">SnowFlake</a> <a href="/tags/索引/" style="font-size: 15px;">索引</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/05/08/java-batis-hashmap/">HashMap源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/07/database-theory/">数据库原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/07/web-short-url/">从短地址说起</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/04/mysql-index/">MySQL索引</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/03/performance-linux/">性能调优</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/03/distributed-system-lock/">分布式锁</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/03/distributed-system-unique-id/">分布式ID生成器</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/03/database-sharding/">数据库水平拆分</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/03/mysql-rules/">MySQL使用规范</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/02/design-pattern-singleton/">Singleton</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://github.com/waterlu" title="waterlu's github" target="_blank">waterlu's github</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">Waterlu's Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>