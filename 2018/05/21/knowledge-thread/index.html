<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="个人技术博客"><title>【置顶】Java多线程一篇就够 | Waterlu's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">【置顶】Java多线程一篇就够</h1><a id="logo" href="/.">Waterlu's Blog</a><p class="description">以铜为鉴，可正衣冠；以史为鉴，可知兴替；以人为鉴，可明得失。</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">【置顶】Java多线程一篇就够</h1><div class="post-meta">May 21, 2018<span> | </span><span class="category"><a href="/categories/并发编程/">并发编程</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><a class="disqus-comment-count" href="/2018/05/21/knowledge-thread/#vcomment"><span class="valine-comment-count" data-xid="/2018/05/21/knowledge-thread/"></span><span> 条评论</span></a><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#线程"><span class="toc-number">1.</span> <span class="toc-text">线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#启动线程"><span class="toc-number">1.1.</span> <span class="toc-text">启动线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#停止线程"><span class="toc-number">1.2.</span> <span class="toc-text">停止线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程属性"><span class="toc-number">1.3.</span> <span class="toc-text">线程属性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程状态"><span class="toc-number">2.</span> <span class="toc-text">线程状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程池"><span class="toc-number">3.</span> <span class="toc-text">线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ExecutorService"><span class="toc-number">3.1.</span> <span class="toc-text">ExecutorService</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Executors"><span class="toc-number">3.2.</span> <span class="toc-text">Executors</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadPoolExecutor"><span class="toc-number">3.3.</span> <span class="toc-text">ThreadPoolExecutor</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#排队逻辑"><span class="toc-number">3.3.1.</span> <span class="toc-text">排队逻辑</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#非核心线程"><span class="toc-number">3.3.2.</span> <span class="toc-text">非核心线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#饱和逻辑"><span class="toc-number">3.3.3.</span> <span class="toc-text">饱和逻辑</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程同步"><span class="toc-number">4.</span> <span class="toc-text">线程同步</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#竞态条件"><span class="toc-number">4.1.</span> <span class="toc-text">竞态条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized"><span class="toc-number">4.2.</span> <span class="toc-text">synchronized</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#偏向锁"><span class="toc-number">4.2.1.</span> <span class="toc-text">偏向锁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#volatile"><span class="toc-number">4.3.</span> <span class="toc-text">volatile</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#wait-notify"><span class="toc-number">4.4.</span> <span class="toc-text">wait/notify</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadLocal"><span class="toc-number">4.5.</span> <span class="toc-text">ThreadLocal</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#final"><span class="toc-number">4.6.</span> <span class="toc-text">final</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java并发包"><span class="toc-number">5.</span> <span class="toc-text">Java并发包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AtomicInteger"><span class="toc-number">5.1.</span> <span class="toc-text">AtomicInteger</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CAS"><span class="toc-number">5.2.</span> <span class="toc-text">CAS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#自旋"><span class="toc-number">5.2.1.</span> <span class="toc-text">自旋</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ABA问题"><span class="toc-number">5.2.2.</span> <span class="toc-text">ABA问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReentrantLock"><span class="toc-number">5.3.</span> <span class="toc-text">ReentrantLock</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Condition"><span class="toc-number">5.3.1.</span> <span class="toc-text">Condition</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AQS"><span class="toc-number">5.4.</span> <span class="toc-text">AQS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#独占模式"><span class="toc-number">5.4.1.</span> <span class="toc-text">独占模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#共享模式"><span class="toc-number">5.4.2.</span> <span class="toc-text">共享模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LockSupport"><span class="toc-number">5.4.3.</span> <span class="toc-text">LockSupport</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BlockingQueue"><span class="toc-number">5.5.</span> <span class="toc-text">BlockingQueue</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayBlockingQueue"><span class="toc-number">5.5.1.</span> <span class="toc-text">ArrayBlockingQueue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LinkedBlockingQueue"><span class="toc-number">5.5.2.</span> <span class="toc-text">LinkedBlockingQueue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SynchronousQueue"><span class="toc-number">5.5.3.</span> <span class="toc-text">SynchronousQueue</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CountDownLatch"><span class="toc-number">5.6.</span> <span class="toc-text">CountDownLatch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Semaphore"><span class="toc-number">5.7.</span> <span class="toc-text">Semaphore</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CyclicBarrier"><span class="toc-number">5.8.</span> <span class="toc-text">CyclicBarrier</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#多线程活性问题"><span class="toc-number">6.</span> <span class="toc-text">多线程活性问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#死锁"><span class="toc-number">6.1.</span> <span class="toc-text">死锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#活锁"><span class="toc-number">6.2.</span> <span class="toc-text">活锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程饥饿"><span class="toc-number">6.3.</span> <span class="toc-text">线程饥饿</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#虚假唤醒"><span class="toc-number">6.4.</span> <span class="toc-text">虚假唤醒</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#信号丢失"><span class="toc-number">6.5.</span> <span class="toc-text">信号丢失</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#生产者-消费者"><span class="toc-number">7.</span> <span class="toc-text">生产者/消费者</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#wait-notify实现"><span class="toc-number">7.1.</span> <span class="toc-text">wait/notify实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lock-Condition实现"><span class="toc-number">7.2.</span> <span class="toc-text">Lock/Condition实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BlockingQueue实现"><span class="toc-number">7.3.</span> <span class="toc-text">BlockingQueue实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java内存模型"><span class="toc-number">8.</span> <span class="toc-text">Java内存模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考资料"><span class="toc-number">9.</span> <span class="toc-text">参考资料</span></a></li></ol></div></div><div class="post-content"><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>线程是操作系统任务调度的基本单位，Java进程至少有一个[main]线程。需要知道如何创建和启动一个线程，如何停止线程以及线程常见的属性。</p>
<h3 id="启动线程"><a href="#启动线程" class="headerlink" title="启动线程"></a>启动线程</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> Task().start();</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Task());</span><br><span class="line">thread.start();</span><br><span class="line">thread.join();</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;Integer&gt;(<span class="keyword">new</span> Task());</span><br><span class="line"><span class="keyword">new</span> Thread(futureTask).start();</span><br><span class="line"><span class="keyword">int</span> value = futureTask.get();</span><br></pre></td></tr></table></figure>
<p><code>new Thread()</code>  只接受Runnable参数，<code>FutureTask implements Runnable</code> 。</p>
<p>FutureTask.get()方法起到和Thead.join()相同的效果，阻塞当前线程直到子线程执行完成并返回执行结果。</p>
<blockquote>
<p><code>Thread.currentThread()</code> 静态方法获取当前线程。</p>
</blockquote>
<h3 id="停止线程"><a href="#停止线程" class="headerlink" title="停止线程"></a>停止线程</h3><p>使用标志位主动退出线程，需要自己编码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> stop = <span class="keyword">false</span>;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!stop) &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>能主动退出是最好的，但不是所有情况都可以主动退出，例如：调用了wait()方法后当前线程被阻塞，就无法判断标志位了，这个时候需要通过外部调用Thread.interrupt()方法来中断线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Thread.sleep();</span></span><br><span class="line">        <span class="comment">// Object.wait();</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// Thread.currentThread().interrupt();</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Task());</span><br><span class="line">thread.start();</span><br><span class="line">thread.interrupt();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意这种代码写法：如果线程正常执行中，那么可以判断isInterrupted()标志位；如果线程阻塞中，外部调用interrupt()方法的效果是中断阻塞操作，抛出InterruptedException异常，捕获异常后需要自己处理退出。换句话说，调用Thread.interrupt()方法后系统不会杀死这个线程，如果当前线程是running状态，系统修改isInterrupted()标志位，如果当前线程是blocked状态，系统抛出InterruptedException异常。捕获异常后，我们可以选择直接退出<code>break</code> ，也可以<code>Thread.currentThread().interrupt();</code> 重置标志位退出。</p>
</blockquote>
<h3 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h3><p>每个线程可以设置一个名字，主线程默认名字是[main]，线程池启动线程默认名字是[pool-1-thread-1]。</p>
<p>线程可以设置优先级，最大MAX_PRIORITY=10，最小MIN_PRIORITY=1，默认NORM_PRIORITY=5。</p>
<p>通过设置daemon属性可以将一个线程设置为守护线程，与守护线程相对的是用户线程，当所有用户线程结束的时候，守护线程自动结束。GC线程是典型的守护线程，用户线程没了，GC线程也没有存在的意义了。</p>
<h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><p><img src="/images/thread_state.png" alt=""></p>
<p>如果我们输出Thread.currentThread().getState()，与上图是对不上的，下面是源码中线程状态的定义。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> State &#123;</span><br><span class="line">  NEW,</span><br><span class="line">  RUNNABLE,</span><br><span class="line">  BLOCKED,</span><br><span class="line">  WAITING,</span><br><span class="line">  TIMED_WAITING,</span><br><span class="line">  TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getState()不区分RUNNABLE和RUNNING状态，我们只能通过日志输出NEW，RUNNABLE和TERMINATED三个状态。</p>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>实战中一般不会使用<code>new Thread().start()</code> 来启动一个线程，通常都使用线程池。使用线程池的原因是创建和销毁线程是有开销的，所以当然就会想到线程的复用，一次创建，多次使用。同时线程池也可以保证在突发大量任务时不会因为创建大量线程耗尽系统资源。</p>
<h3 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a>ExecutorService</h3><p>线程池实现ExecutorService接口，主要有以下四个启动线程的方法：</p>
<ul>
<li>execute(Runnable)，不关注返回值，也不与启动的线程交互；</li>
<li>submit(Runnable)，得不到返回值，但可以通过Future与启动的线程交互；</li>
<li>submit(Runnable, T)，Runnable非要得到返回值（直接用Callable吧）</li>
<li>submit(Callable)，有返回值，可以通过Future与启动的线程交互。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecutorService</span> <span class="keyword">extends</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;	<span class="comment">// 从Executor继承</span></span><br><span class="line">  Future&lt;?&gt; submit(Runnable task);</span><br><span class="line">  &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</span><br><span class="line">  &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般常用的就两种，启动任务就行，那就execute(Runnable)；关心返回值，需要交互，那就submit(Callable)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">ExecutorService executor = Executors.newSingleThreadExecutor();</span><br><span class="line">Future&lt;Integer&gt; future = executor.submit(<span class="keyword">new</span> Task());</span><br><span class="line">Integer result = future.get();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>不用创建FutureTask了，Callable用线程池更直观。</p>
</blockquote>
<h3 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h3><p>使用Executors可以得到ExecutorService接口，常见的有如下三种。Executors实际创建ThreadPoolExecutor实例，但屏蔽了参数细节，不建议使用，建议自己创建ThreadPoolExecutor。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Executors</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 线程池中就1个核心线程，忙就排队</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;&#125;  </span><br><span class="line">  <span class="comment">// 核心线程数是nThreads的线程池，无界排队队列</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;&#125; </span><br><span class="line">  <span class="comment">// 核心线程数0，接收任务就创建新线程执行</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>newSingleThreadExecutor()和newCachedThreadPool()基本无实战价值。</p>
</blockquote>
<h3 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h3><p>几个最重要的参数：</p>
<ul>
<li>corePoolSize，核心线程数</li>
<li>maximumPoolSize，最大线程数</li>
<li>workQueue，排队策略</li>
<li>handler，饱和策略</li>
</ul>
<p><img src="/images/threadpool_threadpoolexecutor.png" alt=""></p>
<p>首先，当线程池中的线程数小于核心线程数时，会为新任务创建新线程，直到达到核心线程数；核心线程完成任务后不会回收；当有新任务到来时，从线程池中选择空闲的核心线程来执行任务，当无核心线程空闲时进入排队逻辑。</p>
<h4 id="排队逻辑"><a href="#排队逻辑" class="headerlink" title="排队逻辑"></a>排队逻辑</h4><p>ArrayBlockingQueue</p>
<p>有界队列，核心线程无空闲时开始排队，队列满以后开启非核心线程，直到最大线程数，超过最大线程数进入饱和逻辑。</p>
<p>LinkedBlockingQueue</p>
<p>无界队列，核心线程无空闲时开始排队，由于队列无界，会一直排队到资源耗尽，最大线程数不起作用。</p>
<p>SynchronousQueue</p>
<p>零界队列，相当于长度为0的队列，不排队直接开启非核心线程，超过最大线程数进入饱和策略。</p>
<h4 id="非核心线程"><a href="#非核心线程" class="headerlink" title="非核心线程"></a>非核心线程</h4><p>开启的非核心线程是可以回收的，当空闲时间超过设定时间keepAliveTime+unit即可回收。线程池不会标记哪个线程是核心线程，哪个线程是非核心线程，线程池关心的是数量。</p>
<h4 id="饱和逻辑"><a href="#饱和逻辑" class="headerlink" title="饱和逻辑"></a>饱和逻辑</h4><p>AbortPolicy</p>
<p>默认的饱和策略，抛出RejectedExecutionException异常。</p>
<p>DiscardPolicy</p>
<p>丢弃当前任务，就当没提交过。</p>
<p>CallerRunsPolicy</p>
<p>在调用者线程中执行run()方法。</p>
<blockquote>
<p>我觉得默认就很好，一般就不要修改饱和策略了。</p>
</blockquote>
<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><p>前面一直关注如何创建和启动线程来完成任务，线程同步关心的是多个线程之间通信的交互的事情。这部分的难度要大一些。</p>
<h3 id="竞态条件"><a href="#竞态条件" class="headerlink" title="竞态条件"></a>竞态条件</h3><p>首先引入竞态条件和临界区的概念，当多个线程同时访问共享变量时，如果执行顺序不同导致结果可能不同，那么我们就说存在竞态条件（Race Condition），引起竞态条件的代码就称为临界区（Critical Section）。</p>
<p>线程同步的三个问题：原子性、可见性和有序性。</p>
<h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p>synchronized关键字起到锁的作用，可以保证原子性、可见性和有序性。synchronized语句块同时只能有一个线程执行，其他线程阻塞等待。synchronized本质上是对一个对象加锁，可以显示声明这个对象，也可以是隐式的。synchronized修饰类的成员方法，相当于对类的实例对象加锁；synchronized修饰类的静态方法，相当于对类对象加锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Math</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Math</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(Math.<span class="keyword">this</span>) &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>Synchronized实现原理：每个对象有一个监视器锁（monitor），当monitor被占用时就会处于锁定状态。进入同步代码块是通过monitorenter指令获取锁，退出同步代码块时通过monitorexit指令释放锁。monitor本身基于操作系统的Mutex和Lock来实现，成本高，所以通常我们称Synchronized为重量级锁。</p>
<p>但是，从JDK1.6开始逐步优化Synchronized的实现，将实现方式分为三级：偏向锁、轻量级锁和重量级锁。加锁过程是一个失败后的升级过程：先尝试加偏向锁，不成功再尝试加轻量级锁，还不成功才使用重量级锁。</p>
<p>轻量级锁是为了在线程交替执行同步块时提高性能，而偏向锁则是在只有一个线程执行同步块时进一步提高性能,以下为个人理解。</p>
<p>偏向锁相当于在Object对象锁上记录线程ID，实际上就是最后一个锁定这个对象的线程ID。加锁时先判断偏向锁，也就是把当前线程ID和锁上记录的最后访问线程ID做比较，如果一样说明只有一个线程在使用，不用加锁。偏向锁在只有一个线程访问synchronized同步块代码时提高了效率。如果线程ID不一样，使用CAS操作（更新LockRecord指针）来抢锁，抢锁成功即加上了轻量级锁，抢锁的操作是自旋的，多次失败进入重量级锁逻辑。</p>
<h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>volatile关键字比synchronized轻量级，可以保证可见性和有序性，但不能保证复合操作的原子性。synchronized相当于限制同一段代码同一时刻只有一个线程执行，把并行改成了串行，所以可以保证没有竞态条件。volatile并不互斥，多线程可以同时直接。volatile修饰的变量保证在写入时立即更新到主内存中，在读取时从主内存中读取，所以volatile可以保证在多个线程中这个变量的值是一样的。</p>
<p>由于volatile关键字不能保证复合操作的原子性，所以volatile最适合修饰boolean变量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> ready = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure>
<p>下面的count++就是复合操作的例子，虽然volatile可以保证count值立即刷新到主内存中，但是由于++操作不是原子操作，所以count++的原子性无法保证。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然在实际工作中volatile的使用远比synchronized少，但理解volatile原理是非常重要的。</p>
<h3 id="wait-notify"><a href="#wait-notify" class="headerlink" title="wait/notify"></a>wait/notify</h3><p>通过修改共享变量的值可以完成线程间通信，但这样读取线程需要一直尝试读取，无法让出CPU，所以我们要引入wait()和notify()方法。</p>
<p>调用wait()方法将使当前线程进入等待状态，直到有其他线程调用了notify()或者notifyAll()方法后唤醒。这里有几点必须注意：</p>
<ul>
<li>虽然实现了线程阻塞和唤醒，但wait()和notify()不是Thread类的方法，是Object类的方法；</li>
<li>wait()和notify()必须在synchronized代码块内使用，也就是说你的先得到对象的锁，然后才可以阻塞或唤醒它；</li>
<li>调用一个对象的notify()方法后，将唤醒一个在这个对象上wait()的线程，如果有多个线程等待，操作系统决定唤醒哪一个；notifyAll()方法唤醒所有在这个对象上wait()的线程；</li>
<li>由于存在虚假唤醒和信号丢失等可能，所以实战中建议使用notifyAll()，比较安全。</li>
</ul>
<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>ThreadLocal可以认为是一种特殊的线程同步操作，为避免共享变量出问题，在每个线程中都创建一个不同的副本，互不影响，实际上就是不共享了。</p>
<blockquote>
<p>代码看上去是共享的，但实际上给每个线程创建了一个对象，最后以线程为key放到一个map中使用。</p>
</blockquote>
<p>在Thread里面有一个静态成员变量<code>ThreadLocal.ThreadLocalMap threadLocals = null;</code> threadLocals是一个所有线程共享的map，这个map的key是Thread.currentThread()，value是ThreadLocal的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">      map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      createMap(t, value);</span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">      ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">      <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        T result = (T)e.value;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重写initialValue()方法可以初始化ThreadLocal的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadLocal&lt;String&gt; uuid = <span class="keyword">new</span> ThreadLocal&lt;String&gt;()&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> String <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> UUID.randomUUID().toString();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><p>final关键字也是避免多线程共享出现竞态条件的一种方法，把共享变量声明为final，不变当然不会出问题。</p>
<h2 id="Java并发包"><a href="#Java并发包" class="headerlink" title="Java并发包"></a>Java并发包</h2><p>Java从1.5开始提供了并行开发包java.util.concurrent，也有人简称JUC。ThreadPoolExecutor就是并发包中的类，下面来看看其他重要的类。</p>
<h3 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h3><p>保证读写是原子操作的Integer。</p>
<p>如果只是为了避免int共享变量的竞态条件，可以使用AtomicInteger。因为synchroznied虽然可以实现，但是太重量级，volatile又不能保证++操作原子性。AtomicInteger类的核心方法是compareAndSet()，也就是CAS。</p>
<h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p>由AtomicInteger引出了CAS，compare and swap，比较并交换。CAS乐观锁机制是Java并行包中很多实现的基础。CAS对应Unsafe类中的compareAndSwap方法，这个方法有三个参数：(1)内存地址、(2)当前值、(3)新值；执行compareAndSwap方法时会判断当前内存地址，如果等于当前值，那么替换为新值并返回成功；如果不等于当期值，那么不做任务操作返回失败。</p>
<p>以AtomicInteger类的getAndIncrement()方法为例，实现原子++，并且返回原值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicInteger</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;    </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原子++操作实际上是调用Unsafe类的getAndAddInt()方法实现的：这个方法一直尝试compareAndSwapInt()。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Unsafe</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object obj, <span class="keyword">long</span> offset, <span class="keyword">int</span> expect, </span></span></span><br><span class="line"><span class="function"><span class="params">                                                <span class="keyword">int</span> update)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object obj, <span class="keyword">long</span> offset, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> expect;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      expect = <span class="keyword">this</span>.getIntVolatile(obj, offset);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(obj, offset, expect, expect + update));</span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Unsafe的CAS操作实际上对应了硬件的CAS型指令，这个指令具有原子性。</p>
</blockquote>
<h4 id="自旋"><a href="#自旋" class="headerlink" title="自旋"></a>自旋</h4><p>上面代码中<code>do {} while(compareAndSwap())</code> 这种操作被称为CAS自旋，自旋这个名词在多线程中经常用到，个人理解就是<code>while(true)</code> 一直尝试的意思，其实很简单，但起了个高大上的名字。</p>
<h4 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h4><p>compare时虽然内存地址上的值是A，与compareAndSwap前读取到的值一样，但这不能说明内存值没有变化，可能发生了A-&gt;B-&gt;A的变化。增加版本号或者时间戳信息可以解决ABA问题。</p>
<p>个人认为，如果内存地址上存储的是int值，那么ABA也不会带来太大问题。但是，如果内存地址上存储的是链表指针，可能就会出大问题。例如：已知链表A-&gt;C，head为头指针指向A元素，需求compareAndSwap(A, C)将head移动到下一个元素C。如果在移动前链表发生了变化，变成了：A-&gt;B，那么compareAndSwap(A, C)判断head还是A，将head=C。实际上C元素已经在A-&gt;B时被删除了，所以这个时候head指到了链表外，就错了。</p>
<h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p>ReentrantLock类实现了Lock接口，顾名思义实现了可重入锁。从一定意义上讲，可以将ReentrantLock类视作synchronzied的替代者。ReentrantLock提供了显示锁，synchronzied提供了隐式锁；ReentrantLock功能更强大，也更复杂，synchronzied简单好理解，并且也在逐步优化。</p>
<blockquote>
<p>两者没有好坏之分，synchronzied简单，如果使用synchronzied可以满足要求，那么使用synchronzied就行；如果synchronzied不能满足要求，那么使用ReentrantLock。</p>
<p>不要想当然认为synchronzied效率低下，synchronzied做了轻量级和偏向锁优化，效率不低。</p>
</blockquote>
<p>ReentrantLock常规用法如下，建议在finally中释放锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  lock.lock();</span><br><span class="line">  ......</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>lock()方法是阻塞的，也可以使用不阻塞的tryLock()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> maxCount = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">while</span>(!lock.tryLock(<span class="number">100</span>, TimeUnit.MILLISECONDS) &amp;&amp; count &lt; maxCount) &#123;</span><br><span class="line">    count++;</span><br><span class="line">  &#125;</span><br><span class="line">  ......</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>tryLock()也是解决死锁问题的一种办法，可以先tryLock()全部资源，都成功后才开始执行。</p>
<p>ReentrantLock提供了公平锁FairSync和非公平锁NonfairSync两种实现，默认使用非公平锁，可通过参数fair选择使用。ReentrantLock基于AbstractQueuedSynchronizer实现，AQS单独讲。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;&#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;&#125;</span><br><span class="line">  <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ReentrantLock是可重入锁，每lock()一次，计数器加1，每unlock()一次，计数器减1。lock()和unlock()一定要成对出现。</p>
<h4 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h4><p>ReentrantLock对应synchronized，ReentrantLock.Condition对应wait/notify，都可以达到相同效果。wait和notify必须在synchronized语句块内，所以Condition对象通过ReentrantLock对象创建。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantConditionDemo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger sum = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Condition condition = lock.newCondition();  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        condition.await();</span><br><span class="line">        logger.info(<span class="string">"sum="</span> + sum.get());</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        sum.getAndIncrement();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        condition.signalAll();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>几个注意的地方：</p>
<ul>
<li>使用<code>lock.newCondition();</code> 创建Condition，一个lock可以创建多个不同的Condition；</li>
<li><code>Condition.await=Object.wait</code> <code>Condition.signal=Object.notify</code> <code>Condition.signalAll=Object.notifyAll</code></li>
<li>调用Condition方法前必须lock.lock()；</li>
<li>wait和notify是Object类的方法，所以Condition类也有这两个方法，不要写错。</li>
</ul>
<p>ReentrantLock.Condition相对wait/notify的增强点：</p>
<ul>
<li>wait/notify是基于Object的，也就是说一个Ojbect被lock以后，如果有多个等待条件，notifyAll都可以触发；例如生产者-消费者中锁定数组对象后，有数组空和数组满两个判断条件，都通过notifyAll触发；</li>
<li>ReentrantLock.Condition的颗粒度比wait/notify小，一个Lock对象可以new多个Condition，也就是说数组空和数组满可以是两个Condition，分别signalAll触发。</li>
</ul>
<h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><p>由ReentrantLock引出了AbstractQueuedSynchronizer同步器，简称AQS。不仅ReentrantLock，BlockingQueue、CountDownLatch和Semaphore等类都是基于AQS实现的，所以AQS是JUC中最重要的一个类。</p>
<p>先从字面理解，AQS是抽象队列同步器。首先这是一个抽象类，使用时需要像ReentrantLock一样继承抽象基类并实现相应方法；其次，AQS目的是同步，所以基于AQS可以实现各种同步功能；最后，AQS是基于队列实现的。</p>
<p>AQS有两种模式：独占模式和共享模式。独占的意思是只有一个线程能够得到锁，其他线程需要在队列里面排队，ReentrantLock就是独占模式。共享的意思是同时可以有多个线程得到锁，Semaphore就是共享模式。</p>
<p>AQS里面有一个volatile修饰的int型变量state，记录了当前锁的状态。以独占模式为例，通过CAS操作更新state状态保证并发时只能有一个线程得到锁，其他线程放到一个queue里面排队。这个queue是通过双向链表实现的，每个节点是一个Node，Node里面记录了排队Thread信息，前一个Node的指针和后一个Node的指针。AQS里面记录了双向链表的头指针head和尾指针tail。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">    Node nextWaiter;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">      selfInterrupt();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">      Node h = head;</span><br><span class="line">      <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">        unparkSuccessor(h);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">      doAcquireShared(arg);</span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">      doReleaseShared();</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：这里有一个小技巧。AbstractQueuedSynchronizer是一个抽象基类，独占模式的接口是acquire和release，共享模式的接口是acquireShared和releaseShared。从代码可以看出，独占模式必须实现tryAcquire和tryRelease方法，由于AQS有两种模式，所以tryAcquire和tryRelease方法没有被声明为abstract，而是采用了抛出异常的方法。也就是说，共享模式不会进入tryAcquire和tryRelease代码，没有问题；独占模式如果子类没有实现这两个方法，将抛出异常。</p>
<p>compareAndSetState()方法通过CAS操作更新state状态，通过state状态就可以判断锁定状态。</p>
<p>head是队列的头指针，head声明为volatile是由于指针的移动也是CAS操作。</p>
<blockquote>
<p>AQS是Java并发包的基础，CAS又是AQS的基础。</p>
</blockquote>
<h4 id="独占模式"><a href="#独占模式" class="headerlink" title="独占模式"></a>独占模式</h4><p>独占模式加锁的处理流程如下：</p>
<ul>
<li>入口acquire()方法；</li>
<li>调用tryAcquire()方法（子类实现）尝试加锁，如果加锁成功直接返回成功；</li>
<li>加锁失败，将线程信息封装到Node节点中，并添加到队列的队尾（CAS+自旋入队尾）；</li>
<li>再次尝试tryAcquire()获取锁，失败后线程进入阻塞；</li>
</ul>
<p>独占模式解锁的处理流程如下：</p>
<ul>
<li>入口release()方法；</li>
<li>调用 tryRelease()方法尝试释放锁；</li>
<li>解锁成功唤醒后继线程；</li>
</ul>
<h4 id="共享模式"><a href="#共享模式" class="headerlink" title="共享模式"></a>共享模式</h4><blockquote>
<p>TODO</p>
</blockquote>
<h4 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h4><p>AQS的线程阻塞和唤醒没有使用Object类的wait()和notify()方法，使用的是LockSupport类的park()和unpark()方法。底层通过Unsafe类native的park()和unpark()方法实现。</p>
<p>wait()和notify()是基于Object的，park()和unpark()是基于Thread的，语义上更好理解。</p>
<h3 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h3><p>BlockingQueue是一个FIFO的阻塞队列，put()方法往队列末尾增加元素，take()方法从队列头读取元素。BlockingQueue有三种实现：ArrayBlockingQueue、LinkedBlockingQueue和SynchronousQueue。</p>
<h4 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h4><p>基于数组实现有界队列，底层基于ReentrantLock实现，notEmpty判断空，notFull判断满。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayBlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Object[] items;</span><br><span class="line">  <span class="keyword">int</span> count;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.items = <span class="keyword">new</span> Object[capacity];</span><br><span class="line">    lock = <span class="keyword">new</span> ReentrantLock(fair);</span><br><span class="line">    notEmpty = lock.newCondition();</span><br><span class="line">    notFull =  lock.newCondition();</span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (count == items.length)</span><br><span class="line">        notFull.await();</span><br><span class="line">      enqueue(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">        notEmpty.await();</span><br><span class="line">      <span class="keyword">return</span> dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h4><p>基于链表实现无界队列，读和写使用了两个锁，count使用AtomicInteger。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedBlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> capacity;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = takeLock.newCondition();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = putLock.newCondition();  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.capacity = Integer.MAX_VALUE;</span><br><span class="line">    last = head = <span class="keyword">new</span> Node&lt;E&gt;(<span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;&#125;</span><br><span class="line">  <span class="keyword">transient</span> Node&lt;E&gt; head;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    putLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (count.get() == capacity) &#123;</span><br><span class="line">        notFull.await();</span><br><span class="line">      &#125;</span><br><span class="line">      enqueue(node);</span><br><span class="line">      c = count.getAndIncrement();</span><br><span class="line">      <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">        notFull.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">      signalNotEmpty();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    E x;</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">    takeLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (count.get() == <span class="number">0</span>) &#123;</span><br><span class="line">        notEmpty.await();</span><br><span class="line">      &#125;</span><br><span class="line">      x = dequeue();</span><br><span class="line">      c = count.getAndDecrement();</span><br><span class="line">      <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line">        notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == capacity)</span><br><span class="line">      signalNotFull();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h4><p>零界队列。</p>
<blockquote>
<p>TODO</p>
</blockquote>
<h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><p>倒计数锁。每次调用<code>countDown()</code> 计数器减1，<code>await();</code> 方法阻塞到计数器为0时返回，起到和join()方法一样的效果。CountDownLatch比Thread.join()更灵活，Thread.join()只能在线程结束后返回，CountDownLatch可以在任何位置调用countDown()方法。另外，我们通常使用线程池启动子线程，子线程只需要实现runnable接口，这种情况下Thread类对象是封装在线程池里面的，我们不方便拿到，也就不方便调用它的join()方法；使用CountDownLatch就简单多了，只需要在run()方法退出前调用countDown()方法即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> CountDownLatch counter;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(CountDownLatch counter)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.counter = counter;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    counter.countDown();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CountDownLatch counter = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line">Task task = <span class="keyword">new</span> Task(counter);</span><br><span class="line">ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">2</span>; i++) &#123;</span><br><span class="line">  executorService.execute(task);</span><br><span class="line">&#125;</span><br><span class="line">counter.await();</span><br></pre></td></tr></table></figure>
<h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><p>信号量和锁有点类似，区别是ReetrantLock是独占锁，只能锁一次，Semaphore是共享锁，可以锁多次。</p>
<p>Semaphore的acquire()/release()方法和lock()/unlock()方法一样需要成对使用。区别在于lock()方法只能有1个线程通过，acquire()方法可以有多个线程通过。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    semaphore.acquire();</span><br><span class="line">	......</span><br><span class="line">    semaphore.release();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><p>循环栅栏，所有等待线程等到最后一个执行完成后再同步前进，可以指定下一步任务。不常用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>, <span class="keyword">new</span> MainTask());</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    barrier.await();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="多线程活性问题"><a href="#多线程活性问题" class="headerlink" title="多线程活性问题"></a>多线程活性问题</h2><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>两个线程互相等待对方的资源而被阻塞。线程1锁定资源A，申请资源B，线程2锁定资源B，申请资源A，就出现死锁。典型的例子：哲学家进餐问题、父节点和子节点互相添加。</p>
<p>哲学家进餐问题：五个哲学家做在一个圆桌上，只有五支筷子，哲学家需要左右手各拿到一支才可以进餐。哲学家全都先拿起左手筷子，再拿起右手筷子，然后再进餐。可能出现五个哲学家全部左手拿筷子的情况，形成死锁。</p>
<p>解决方法一：锁定全部筷子</p>
<p>一次拿走全部筷子，然后再进餐，这样不会死锁，但同时只能有一个人进餐，虽然还富余三支筷子。</p>
<p>解决方法二：严格锁定顺序</p>
<p>都按照一个顺序来加锁。这点可能感到奇怪，先加左手筷子锁，再加右手筷子锁，顺序是一样的啊。主要原因是圆桌，左手和右手是相对的，A的右手可能就是B的左手。解决方案：给所有筷子从1到5编号，先加小号锁，再加大号锁。编号是绝对的，保证从小到大的加锁顺序可以避免死锁。</p>
<p>解决方法三：尝试加锁</p>
<p>使用ReentrantLock类的tryLock()方法尝试给两支筷子加锁，都成功才可以进餐。</p>
<h3 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h3><p>一直尝试加锁，一直失败得不到锁，就是活锁现象。</p>
<h3 id="线程饥饿"><a href="#线程饥饿" class="headerlink" title="线程饥饿"></a>线程饥饿</h3><p>多个线程竞争同一个锁，如果一直有新的线程加入竞争，可能出现某个线程永远得不到锁的情况。</p>
<p>使用ReentrantLock的公平锁可以解决线程饥饿问题，公平锁保证按照排队顺序唤醒下一个线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>
<p>注意：公平锁带来了额外的成本，所以通常实现统计意义上的公平即可，无需实现排队公平。</p>
<h3 id="虚假唤醒"><a href="#虚假唤醒" class="headerlink" title="虚假唤醒"></a>虚假唤醒</h3><p>调用wait()方法后处于blocked状态的线程，在没有其他线程调用notify()方法的情况下被系统唤醒，称为虚假唤醒。</p>
<p>为避免虚假唤醒带来的问题，进入wait()的判断条件不用if，用while，这样唤醒后会再判断一遍。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(condition) &#123;</span><br><span class="line">    object.wait();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="信号丢失"><a href="#信号丢失" class="headerlink" title="信号丢失"></a>信号丢失</h3><p>调用wait()方法后等待notify()方法唤醒，但是不幸的是notify()方法已经在wait()方法执行前执行了，那么wait()永远等不到唤醒信息。</p>
<h2 id="生产者-消费者"><a href="#生产者-消费者" class="headerlink" title="生产者/消费者"></a>生产者/消费者</h2><h3 id="wait-notify实现"><a href="#wait-notify实现" class="headerlink" title="wait/notify实现"></a>wait/notify实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerConsumerDemo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger LOGGER = LoggerFactory.getLogger(ProducerConsumerDemo.class);</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;String&gt; storeList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Producer producer = <span class="keyword">new</span> Producer(storeList, <span class="string">"producer"</span> + (i+<span class="number">1</span>));</span><br><span class="line">    Consumer consumer = <span class="keyword">new</span> Consumer(storeList, <span class="string">"consumer"</span> + (i+<span class="number">1</span>));</span><br><span class="line">    producer.start();</span><br><span class="line">    consumer.start();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 生产者</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;String&gt; storeList;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(LinkedList&lt;String&gt; storeList, String name)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.storeList = storeList;</span><br><span class="line">      <span class="keyword">this</span>.setName(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (storeList)&#123;</span><br><span class="line">          <span class="comment">// 库存满了阻塞等待消费</span></span><br><span class="line">          <span class="keyword">while</span>(storeList.size() == MAX) &#123;</span><br><span class="line">            LOGGER.info(<span class="string">"库存满了"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              storeList.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 生产20个以后退出</span></span><br><span class="line">          <span class="keyword">if</span> (count.intValue() &gt; <span class="number">20</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 生产数据</span></span><br><span class="line">          String data = String.format(<span class="string">"%04d"</span>, count.getAndIncrement());</span><br><span class="line">          storeList.add(data);</span><br><span class="line">          LOGGER.info(<span class="string">"生产 "</span> + data);</span><br><span class="line">          <span class="comment">// 等一会</span></span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 唤醒等待消费的线程</span></span><br><span class="line">          storeList.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 消费者</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;String&gt; storeList;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(LinkedList&lt;String&gt; storeList, String name)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.storeList = storeList;</span><br><span class="line">      <span class="keyword">this</span>.setName(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (storeList)&#123;</span><br><span class="line">          <span class="comment">// 库存空了阻塞等待生产</span></span><br><span class="line">          <span class="keyword">while</span>(storeList.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            LOGGER.info(<span class="string">"库存空了"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              storeList.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 消费掉第一个数据</span></span><br><span class="line">          String data = storeList.get(<span class="number">0</span>);</span><br><span class="line">          LOGGER.info(<span class="string">"消费 "</span> + data);</span><br><span class="line">          storeList.remove(<span class="number">0</span>);</span><br><span class="line">          <span class="comment">// 等一会</span></span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 唤醒等待生产的线程</span></span><br><span class="line">          storeList.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Lock-Condition实现"><a href="#Lock-Condition实现" class="headerlink" title="Lock/Condition实现"></a>Lock/Condition实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerConsumerDemo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(ProducerConsumerDemo.class);</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;Integer&gt; store = <span class="keyword">new</span> LinkedList();</span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    Condition full = lock.newCondition();</span><br><span class="line">    Condition empty = lock.newCondition();</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    Producer producer = <span class="keyword">new</span> Producer(store, lock, full,empty);</span><br><span class="line">    Consumer consumer = <span class="keyword">new</span> Consumer(store, lock, full,empty);</span><br><span class="line">    executorService.submit(producer);</span><br><span class="line">    executorService.submit(consumer);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 生产者</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LinkedList&lt;Integer&gt; store;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock lock;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition full;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition empty;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(LinkedList store, Lock lock, Condition full, Condition empty)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.store = store;</span><br><span class="line">      <span class="keyword">this</span>.lock = lock;</span><br><span class="line">      <span class="keyword">this</span>.full = full;</span><br><span class="line">      <span class="keyword">this</span>.empty = empty;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">while</span> (count &lt; <span class="number">20</span>)&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          lock.lock();</span><br><span class="line">          <span class="keyword">while</span> (store.size() &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">            full.await();</span><br><span class="line">          &#125;</span><br><span class="line">          count++;</span><br><span class="line">          Integer data = <span class="keyword">new</span> Integer(count);</span><br><span class="line">          store.add(data);</span><br><span class="line">          logger.info(<span class="string">"生产 "</span> + data);</span><br><span class="line">          Thread.sleep(<span class="number">500</span>);</span><br><span class="line">          empty.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 消费者</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LinkedList&lt;Integer&gt; store;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock lock;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition full;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition empty;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(LinkedList store, Lock lock, Condition full, Condition empty)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.store = store;</span><br><span class="line">      <span class="keyword">this</span>.lock = lock;</span><br><span class="line">      <span class="keyword">this</span>.full = full;</span><br><span class="line">      <span class="keyword">this</span>.empty = empty;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          lock.lock();</span><br><span class="line">          <span class="keyword">while</span> (store.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            empty.await();</span><br><span class="line">          &#125;</span><br><span class="line">          Integer data = store.get(<span class="number">0</span>);</span><br><span class="line">          store.remove(<span class="number">0</span>);</span><br><span class="line">          logger.info(<span class="string">"消费 "</span> + data);</span><br><span class="line">          Thread.sleep(<span class="number">500</span>);</span><br><span class="line">          full.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="BlockingQueue实现"><a href="#BlockingQueue实现" class="headerlink" title="BlockingQueue实现"></a>BlockingQueue实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerConsumerDemo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger logger = LoggerFatory.getLogger(ProducerConsumerDemo.class);</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    BlockingQueue queue = <span class="keyword">new</span> ArrayBlockingQueue(<span class="number">10</span>);</span><br><span class="line">    Producer producer = <span class="keyword">new</span> Producer(queue);</span><br><span class="line">    Consumer consumer = <span class="keyword">new</span> Consumer(queue);</span><br><span class="line">    <span class="keyword">new</span> Thread(producer).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(consumer).start();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 生产者</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> BlockingQueue queue = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(BlockingQueue queue)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">while</span> (count &lt; <span class="number">20</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          count++;</span><br><span class="line">          queue.put(<span class="keyword">new</span> Integer(count));</span><br><span class="line">          logger.info(<span class="string">"生产 "</span> + count);</span><br><span class="line">          Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 消费者</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> BlockingQueue queue = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(BlockingQueue queue)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          logger.info(<span class="string">"消费 "</span> + queue.take());</span><br><span class="line">          Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.cnblogs.com/paddix/p/5405678.html" target="_blank" rel="noopener">Java并发编程：Synchronized底层优化（偏向锁、轻量级锁）</a></p>
<p><a href="http://www.coolblog.xyz/2018/05/01/AbstractQueuedSynchronizer-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90-%E7%8B%AC%E5%8D%A0-%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">AbstractQueuedSynchronizer 原理分析 - 独占/共享模式</a></p>
<p><a href="https://www.jianshu.com/p/cc2281b1a6bc" target="_blank" rel="noopener">【Java并发编程】—–“J.U.C”：LinkedBlockingQueue</a></p>
</div><div class="tags"><a href="/tags/多线程/">多线程</a></div><div class="post-nav"><a class="pre" href="/2018/05/22/spring-ioc/">Spring-IoC</a><a class="next" href="/2018/05/18/springboot-devtool-deploy/">SpringBoot热部署</a></div><div id="vcomment"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script><script>var notify = 'false' == true ? true : false;
var verify = 'false' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'5mrT8f80zgJVcJvIPrSGzFjV-gzGzoHsz',
  appKey:'Db9rWWROewfegKQJkbYncKt1',
  placeholder:'请在这里留下你要说的话',
  avatar:'mm',
  guest_info:guest_info,
  pageSize:'10'
})</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JAVA/">JAVA</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/WEB/">WEB</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/分布式/">分布式</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/工具/">工具</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/并发编程/">并发编程</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/消息队列/">消息队列</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/">设计模式</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/hashCode/" style="font-size: 15px;">hashCode</a> <a href="/tags/mq/" style="font-size: 15px;">mq</a> <a href="/tags/并发/" style="font-size: 15px;">并发</a> <a href="/tags/线程/" style="font-size: 15px;">线程</a> <a href="/tags/线程池/" style="font-size: 15px;">线程池</a> <a href="/tags/任务调度/" style="font-size: 15px;">任务调度</a> <a href="/tags/排队策略/" style="font-size: 15px;">排队策略</a> <a href="/tags/饱和策略/" style="font-size: 15px;">饱和策略</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/github/" style="font-size: 15px;">github</a> <a href="/tags/多线程/" style="font-size: 15px;">多线程</a> <a href="/tags/synchronized/" style="font-size: 15px;">synchronized</a> <a href="/tags/wait/" style="font-size: 15px;">wait</a> <a href="/tags/notify/" style="font-size: 15px;">notify</a> <a href="/tags/单例/" style="font-size: 15px;">单例</a> <a href="/tags/线程安全/" style="font-size: 15px;">线程安全</a> <a href="/tags/Database/" style="font-size: 15px;">Database</a> <a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/Sharding/" style="font-size: 15px;">Sharding</a> <a href="/tags/分布式/" style="font-size: 15px;">分布式</a> <a href="/tags/SnowFlake/" style="font-size: 15px;">SnowFlake</a> <a href="/tags/索引/" style="font-size: 15px;">索引</a> <a href="/tags/mybatis/" style="font-size: 15px;">mybatis</a> <a href="/tags/WEB/" style="font-size: 15px;">WEB</a> <a href="/tags/短地址/" style="font-size: 15px;">短地址</a> <a href="/tags/哈希/" style="font-size: 15px;">哈希</a> <a href="/tags/rocketmq/" style="font-size: 15px;">rocketmq</a> <a href="/tags/springboot/" style="font-size: 15px;">springboot</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/Hashmap/" style="font-size: 15px;">Hashmap</a> <a href="/tags/哈希冲突/" style="font-size: 15px;">哈希冲突</a> <a href="/tags/SpringBoot/" style="font-size: 15px;">SpringBoot</a> <a href="/tags/热部署/" style="font-size: 15px;">热部署</a> <a href="/tags/Reentrantlock/" style="font-size: 15px;">Reentrantlock</a> <a href="/tags/内存模型/" style="font-size: 15px;">内存模型</a> <a href="/tags/内存可见性/" style="font-size: 15px;">内存可见性</a> <a href="/tags/指令重排序/" style="font-size: 15px;">指令重排序</a> <a href="/tags/ConcurrentHashMap/" style="font-size: 15px;">ConcurrentHashMap</a> <a href="/tags/注解/" style="font-size: 15px;">注解</a> <a href="/tags/Spring/" style="font-size: 15px;">Spring</a> <a href="/tags/AOP/" style="font-size: 15px;">AOP</a> <a href="/tags/动态代理/" style="font-size: 15px;">动态代理</a> <a href="/tags/IoC/" style="font-size: 15px;">IoC</a> <a href="/tags/Spring-Cloud/" style="font-size: 15px;">Spring Cloud</a> <a href="/tags/Eureka/" style="font-size: 15px;">Eureka</a> <a href="/tags/服务治理/" style="font-size: 15px;">服务治理</a> <a href="/tags/反射/" style="font-size: 15px;">反射</a> <a href="/tags/Ribbon/" style="font-size: 15px;">Ribbon</a> <a href="/tags/泛型/" style="font-size: 15px;">泛型</a> <a href="/tags/Mybatis/" style="font-size: 15px;">Mybatis</a> <a href="/tags/InnoDB/" style="font-size: 15px;">InnoDB</a> <a href="/tags/Git/" style="font-size: 15px;">Git</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/08/27/algorithm-basic/">算法-常见算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/09/notebook-mysql-inside-innodb-engine/">读书笔记-MySQL技术内幕（1）</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/08/tool-gitflow/">GitFlow</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/07/springcloud-ribbon/">Spring Cloud - Ribbon</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/06/springcloud-eureka/">Spring Cloud - Eureka</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/05/spring-ioc-inside/">Spring-IoC原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/spring-ioc-advanced/">Spring-IoC进阶</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/31/mybatis-aop/">Mybatis动态代理原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/29/java-basic-generic/">Java基础-泛型</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/28/java-basic-proxy/">Java基础-动态代理</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://github.com/waterlu" title="waterlu's github" target="_blank">waterlu's github</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">Waterlu's Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>