<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="个人技术博客"><title>Spring-AOP | Waterlu's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Spring-AOP</h1><a id="logo" href="/.">Waterlu's Blog</a><p class="description">以铜为鉴，可正衣冠；以史为鉴，可知兴替；以人为鉴，可明得失。</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Spring-AOP</h1><div class="post-meta">May 27, 2018<span> | </span><span class="category"><a href="/categories/Spring/">Spring</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><a class="disqus-comment-count" href="/2018/05/27/spring-aop/#vcomment"><span class="valine-comment-count" data-xid="/2018/05/27/spring-aop/"></span><span> 条评论</span></a><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-AOP"><span class="toc-number">1.</span> <span class="toc-text">Spring AOP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AOP"><span class="toc-number">1.1.</span> <span class="toc-text">AOP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-AOP-1"><span class="toc-number">1.2.</span> <span class="toc-text">Spring AOP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#概念"><span class="toc-number">1.3.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用"><span class="toc-number">1.4.</span> <span class="toc-text">使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#XML配置"><span class="toc-number">1.4.1.</span> <span class="toc-text">XML配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#注解配置"><span class="toc-number">1.4.2.</span> <span class="toc-text">注解配置</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#原理"><span class="toc-number">1.5.</span> <span class="toc-text">原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AspectJ"><span class="toc-number">1.5.1.</span> <span class="toc-text">AspectJ</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK动态代理"><span class="toc-number">1.5.2.</span> <span class="toc-text">JDK动态代理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CGLib动态代理"><span class="toc-number">1.5.3.</span> <span class="toc-text">CGLib动态代理</span></a></li></ol></li></ol></li></ol></div></div><div class="post-content"><h2 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h2><h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p>什么是AOP，AOP=Aspect Oriented Program，翻译过来就是面向切面编程。AOP与OOP是同等重要的概念，OOP是面向对象编程，面向对象的特点是封装、继承和多态。OOP是一种思想，通过把现实世界中的业务抽象描述成对象来解决问题；每个对象对应不同的业务功能，对象设计以高内聚、低耦合为目标。AOP也是一种思想，这里Aspect 的意思是横切面，或者说是各个对象的横切面，所以AOP是跨对象的，AOP解决的是各个对象的共性问题。OOP设计与具体业务强相关，AOP则是提供非业务功能的统一处理。</p>
<blockquote>
<p>打个不恰当的比喻，AOP就像是做肉夹馍，横着把馍切开，把肉和菜放进去。如果我们有很多馍，一个一个分别切开放肉是传统做法；AOP做法是找一把很长的刀，把馍排行队，一次横向把所有馍都切开，把肉一起放进去。</p>
</blockquote>
<p>简单说，AOP目的是在OOP的基础上，把各个对象中与具体业务无关的共性功能提取出来，做统一处理，这样就避免了各个对象重复建设，也方便统一管理。例如：日志输出、异常处理、事务控制、权限控制、缓存处理等功能很多对象都需要使用，与具体业务无关，如果每个对象都自己实现这些功能显然是重复且低效的，把这些共性功能提取到一个切面中进行统一管理，这就是面向切面编程。所以，面向切面编程一般都是统一xxx处理。看到这，你也许会认为这不就是拦截器吗，对，我认为拦截器就是AOP编程思想的一种体现，但AOP并不限于拦截器。</p>
<h3 id="Spring-AOP-1"><a href="#Spring-AOP-1" class="headerlink" title="Spring AOP"></a>Spring AOP</h3><p>那什么是Spring AOP呢？我认为，Spring AOP就是Spring框架提供的面向切面编程的功能。具体又可以分为两块：一个是Spring框架本身提供的很多功能就是基于AOP实现的；还有一个就是我们自己也可以使用Spring完成面向切面编程的功能。</p>
<p>AOP这个名词听上去可能有点陌生，但实际上我们在代码中早已经使用过了，<code>@Transational</code> 和<code>@Cacheable</code> 这两个常用的注解就是基于AOP实现的。</p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>在学习使用Spring AOP之前，我们先来了解一些概念，这些概念是枯燥乏味的，我尽量用通俗的语言来解释。</p>
<p>Aspect - 切面，可以理解为一个横切多个对象的<strong>功能</strong>，例如：访问日志输出，访问权限控制等；</p>
<p>PointCut - 切入点，可以理解为对象的哪个<strong>方法</strong>需要被切开放入切面功能，例如：所有以set开头的方法；</p>
<p>Advice - 通知，分为前置、后置、异常和环绕四种；</p>
<p>JoinPoint - 连接点，主动切入的切面对象和被切入对象的连接处？</p>
<p>Weaving- 织入，完成切入的<strong>过程</strong>被称为织入。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>上面的概念还是太抽象，我们通过具体的例子来学习AOP，看看如何自定义切面。</p>
<h4 id="XML配置"><a href="#XML配置" class="headerlink" title="XML配置"></a>XML配置</h4><p>看看xml中如何配置一个切面。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">"aspectLog"</span> <span class="attr">ref</span>=<span class="string">"logAspect"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"public"</span> <span class="attr">expression</span>=<span class="string">"execution(* cn.lu.spring.aop.Human.*(..))"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">"before"</span> <span class="attr">pointcut-ref</span>=<span class="string">"public"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">"afterReturn"</span> <span class="attr">pointcut-ref</span>=<span class="string">"public"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">"after"</span> <span class="attr">pointcut-ref</span>=<span class="string">"public"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">method</span>=<span class="string">"afterThrow"</span> <span class="attr">pointcut-ref</span>=<span class="string">"public"</span> /&gt;</span>     </span><br><span class="line">      <span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">"around"</span> <span class="attr">pointcut-ref</span>=<span class="string">"public"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>首先，切面配置必须包含在<code>&lt;aop:config&gt;</code> 中； </li>
<li>使用<code>&lt;aop:aspect&gt;</code> 来声明一个切面功能，一个<code>&lt;aop:config&gt;</code> 中可以声明多个<code>&lt;aop:aspect&gt;</code>  ；</li>
<li>一个切面<code>&lt;aop:aspect&gt;</code> 有且仅有一个切入点<code>&lt;aop:pointcut&gt;</code> ，切入点通过表达式限定需要切入的方法范围，本例为切入到Human类的所有方法中；切入点就是声明切入到哪个目标方法执行；</li>
<li>最后还需要定义Advice通知，就是确定切面方法执行和目标方法执行的关系，有五种：<ul>
<li><code>&lt;aop:before&gt;</code> 前置通知，切面方法在切入目标方法执行之前执行；</li>
<li><code>&lt;aop:after-returning&gt;</code> 返回前通知，切面方法在切入目标方法执行完成返回接过前执行；</li>
<li><code>&lt;aop:after&gt;</code> 后置通知，切面方法在切入目标方法执行之后执行；</li>
<li><code>&lt;aop:after-throwing&gt;</code> 异常通知，切面方法在切入目标方法抛出异常以后执行；</li>
<li><code>&lt;aop:aroud&gt;</code> 环绕通知，给了切面方法更大的自由，可以自定义；</li>
</ul>
</li>
</ul>
<p>配置完成后，我们通过JUnitTest运行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AOPWithXML</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> ApplicationContext context;</span><br><span class="line">  <span class="meta">@Before</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"classpath:spring-aop.xml"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Human human = context.getBean(Human.class);</span><br><span class="line">    human.go();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然我们从容器中取出的是Human类的实例对象，调用的也是Human类方法，但输出了切面类的日志信息，这说明切入成功</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">LogAspect before</span><br><span class="line">LogAspect around 1</span><br><span class="line">Human go()</span><br><span class="line">LogAspect around 2</span><br><span class="line">LogAspect after</span><br><span class="line">LogAspect afterReturn</span><br></pre></td></tr></table></figure>
<p>Human类很简单，go方法什么也不做，只输出一行日志，我们看一下LogAspect类，就是<code>&lt;aop:aspect&gt;</code> 对应的切面类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogAspect</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"LogAspect before"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"LogAspect afterReturn"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"LogAspect after"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"LogAspect afterThrow"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">around</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"LogAspect around 1"</span>);</span><br><span class="line">        Object value = joinPoint.proceed();</span><br><span class="line">        System.out.println(<span class="string">"LogAspect around 2"</span>);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>综上，我们可以根据业务需求使用<code>&lt;aop:aspect&gt;</code>配置切面类，具体通过<code>&lt;aop:pointcut&gt;</code> 指定切入点就是被切入的方法，然后通过<code>&lt;aop:before&gt;</code>和<code>&lt;aop:after&gt;</code>定义切面方法并指定执行的位置，最后在切面类中编写代码即可。例子中的切面类LogAspect实现了日志输出功能，延伸一点，使用<code>&lt;aop:aroud&gt;</code> 可以统计方法的执行时间。</p>
<h4 id="注解配置"><a href="#注解配置" class="headerlink" title="注解配置"></a>注解配置</h4><p>同样的功能，我们再来看看用注解如何完成。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogAspect</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* cn.lu.spring.aop.Human.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointCut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"pointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"LogAspect before"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@AfterReturning</span>(<span class="string">"pointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"LogAspect afterReturn"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@After</span>(<span class="string">"pointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"LogAspect after"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@AfterThrowing</span>(<span class="string">"pointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"LogAspect afterThrow"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"pointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">around</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"LogAspect around 1"</span>);</span><br><span class="line">        Object value = joinPoint.proceed();</span><br><span class="line">        System.out.println(<span class="string">"LogAspect around 2"</span>);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码相当于对xml文件做了一次翻译工作，很好理解，只是@PointCut这种写法有点奇怪。当然，如果你不嫌麻烦也可以不定义@PointCut，直接这样写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogAspect</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"execution(* cn.lu.spring.aop.Human.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"LogAspect before"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有一点需要注意，需要先开启AspectJ，下面用@EnableAspectJAutoProxy注解开启AspectJ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AopConfig</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Human <span class="title">human</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Human();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> LogAspect <span class="title">logAspect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LogAspect();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>以上两种方法，无论xml配置还是@Aspect注解配置，都是用静态代理实现AOP。Spring使用AspectJ实现静态代理，所以上面的例子需要引入AsprectJ包。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>否则使用XML配置会抛出如下异常：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">NoClassDefFoundError: org/aspectj/weaver/reflect/ReflectionWorld</span><br></pre></td></tr></table></figure>
<p>使用@Aspect注解就更不用说了，@Aspect注解在<code>org.aspectj.lang.annotation.*;</code> 包中定义。也就是说@Aspect不是Spring的注解，是AspectJ的注解。</p>
<p>Spring实现AOP有三种方式：</p>
<ul>
<li>AspectJ - 静态代理，编译期实现AOP；</li>
<li>JDK动态代理 - 动态代理，运行期实现，基于接口实现的AOP；</li>
<li>CGLib动态代理 - 动态代理，运行期实现，无接口时实现AOP。</li>
</ul>
<p>由于Spring框架倡导基于接口编程，所以实际上JDK动态代理使用的最多。</p>
<h4 id="AspectJ"><a href="#AspectJ" class="headerlink" title="AspectJ"></a>AspectJ</h4><p>AspectJ可以理解为Java的Aspect实现，也就是Java提供的一个实现AOP的包，那和Spring AOP有什么关系呢？就像OOP一样，AOP是一种思想或者编程方法，和具体开发语言和开发框架无关。C++和Java都可以实现面向对象编程，同样道理，AOP的实现方式也是多种多样的。Java有自己的AOP实现，JBoss有自己的AOP实现，Spring也有自己的AOP实现。Spring的AOP实现在静态的情况下，直接使用了AspectJ实现，就是这么简单。</p>
<blockquote>
<p> 因为Spring只是做了配置，真正实现在AspectJ中，所以我们必须在pom.xml中引入AspectJ的包。</p>
</blockquote>
<p>AspectJ的实现方式是在编译期间自动生成Java字节码，也可以理解为一种Java编译器。编译时，AspectJ根据配置修改原始的.class文件，添加增强代码，形成新的.class文集。所谓增强代码就称为Advice，添加增强代码的位置就是JoinPoint，合并的过程就称为织入。</p>
<p>AspectJ的好处是非侵入，不需要像JDK动态代理一样必须要定义接口。</p>
<p><strong>AspectJ揭秘</strong></p>
<p>下面我们来看一看AspectJ都做了什么，打开Human.java文件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Human go()"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在打开target/classes目录下的Human.class文件，IDEA自动帮我们反编译成java源文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Human</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                LogAspect.aspectOf().before();</span><br><span class="line">                System.out.println(<span class="string">"Human go()"</span>);</span><br><span class="line">                LogAspect.aspectOf().afterReturn();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">                LogAspect.aspectOf().after();</span><br><span class="line">                <span class="keyword">throw</span> var3;</span><br><span class="line">            &#125;</span><br><span class="line">            LogAspect.aspectOf().after();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            LogAspect.aspectOf().afterThrow();</span><br><span class="line">            <span class="keyword">throw</span> var4;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样再看看target/classes目录下的LogAspect.class文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogAspect</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">LogAspect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Before</span>(<span class="string">"pointCut()"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"LogAspect before"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LogAspect <span class="title">aspectOf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ajc$perSingletonInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NoAspectBoundException(<span class="string">"cn.lu.spring.aop.LogAspect"</span>, ajc$initFailureCause);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> ajc$perSingletonInstance;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasAspect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ajc$perSingletonInstance != <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      ajc$postClinit();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable var1) &#123;</span><br><span class="line">      ajc$initFailureCause = var1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p> 这里不分析AspectJ实现的细节，大家只要知道AspectJ在编译时修改.class文件添加功能增强代码即可。</p>
</blockquote>
<p>当然，现在如果你打开Human.class文件就会发现根本没有AspectJ织入的增强代码。这是因为我提前做了AspectJ相关的配置，为了看到这些增强代码，你需要修改IDEA和项目的配置。</p>
<ol>
<li>首先，请确认IDEA安装了AspectJ相关的两个插件：AspectJ Support和Spring AOP/@AspectJ。</li>
<li>然后，我们需要修改Java编译器。在Setting-&gt;Build-&gt;Comiler中找到Java Compiler，修改”Use compiler”的选项，将”Javac”修改为Ajc。从这里也可以印证AspectJ是在编译器上做的手脚。</li>
</ol>
<p>在”Path to Ajc compiler”项目输入aspectjtools.jar的全路径名，可以去<a href="http://www.eclipse.org/downloads/download.php?file=/tools/aspectj/aspectj-1.8.9.jar" target="_blank" rel="noopener">这里</a> 下载。如果下载速度非常慢（我就是这样）也可以去<a href="https://mvnrepository.com" target="_blank" rel="noopener">maven库</a> 中下载。我这里使用的是1.8.9版本，下载到了maven库中，所以我的配置如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">C:\Users\lu\.m2\repository\org\aspectj\aspectjtools\1.8.9\aspectjtools-1.8.9.jar</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>接下来，修改项目配置。先在pom.xml中添加aspectjrt包依赖（我这里选用的都是1.8.9版本）。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjrt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后进入Proejct Structure-&gt;Modules-&gt;Dependencies，勾选org.aspectj:aspectjrt:1.8.9。</p>
<ol start="4">
<li>最后，在Application的启动参数VM Options里面添加<code>-javaagent:</code> ，指向aspectjweaver.jar，我的配置如下：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-javaagent:C:/Users/lu/.m2/repository/org/aspectj/aspectjweaver/1.8.9/aspectjweaver-1.8.9.jar</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>好了，以上配置完成以后，重新编译运行就能在.class文件中看到AspectJ织入的增强代码了。</li>
</ol>
<p>以上都是为了证明AspectJ是在编译期实现的静态AOP。</p>
<h4 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h4><p>我专门有一篇文章介绍JDK动态代理，这里不再赘述，只关于Spring如何使用JDK动态代理。</p>
<h4 id="CGLib动态代理"><a href="#CGLib动态代理" class="headerlink" title="CGLib动态代理"></a>CGLib动态代理</h4><p>### </p>
<p><a href="https://www.colabug.com/2102191.html" target="_blank" rel="noopener">https://www.colabug.com/2102191.html</a></p>
<p><a href="http://sexycoding.iteye.com/blog/1062372" target="_blank" rel="noopener">http://sexycoding.iteye.com/blog/1062372</a></p>
</div><div class="tags"><a href="/tags/Spring/">Spring</a><a href="/tags/AOP/">AOP</a></div><div class="post-nav"><a class="pre" href="/2018/05/28/java-basic-reflect/">Java基础-反射</a><a class="next" href="/2018/05/22/spring-ioc/">Spring-IoC</a></div><div id="vcomment"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script><script>var notify = 'false' == true ? true : false;
var verify = 'false' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'5mrT8f80zgJVcJvIPrSGzFjV-gzGzoHsz',
  appKey:'Db9rWWROewfegKQJkbYncKt1',
  placeholder:'请在这里留下你要说的话',
  avatar:'mm',
  guest_info:guest_info,
  pageSize:'10'
})</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JAVA/">JAVA</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/WEB/">WEB</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/分布式/">分布式</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/工具/">工具</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/并发编程/">并发编程</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/消息队列/">消息队列</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/">设计模式</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/hashCode/" style="font-size: 15px;">hashCode</a> <a href="/tags/mq/" style="font-size: 15px;">mq</a> <a href="/tags/并发/" style="font-size: 15px;">并发</a> <a href="/tags/线程/" style="font-size: 15px;">线程</a> <a href="/tags/线程池/" style="font-size: 15px;">线程池</a> <a href="/tags/任务调度/" style="font-size: 15px;">任务调度</a> <a href="/tags/排队策略/" style="font-size: 15px;">排队策略</a> <a href="/tags/饱和策略/" style="font-size: 15px;">饱和策略</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/github/" style="font-size: 15px;">github</a> <a href="/tags/多线程/" style="font-size: 15px;">多线程</a> <a href="/tags/synchronized/" style="font-size: 15px;">synchronized</a> <a href="/tags/wait/" style="font-size: 15px;">wait</a> <a href="/tags/notify/" style="font-size: 15px;">notify</a> <a href="/tags/单例/" style="font-size: 15px;">单例</a> <a href="/tags/线程安全/" style="font-size: 15px;">线程安全</a> <a href="/tags/Database/" style="font-size: 15px;">Database</a> <a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/Sharding/" style="font-size: 15px;">Sharding</a> <a href="/tags/分布式/" style="font-size: 15px;">分布式</a> <a href="/tags/SnowFlake/" style="font-size: 15px;">SnowFlake</a> <a href="/tags/索引/" style="font-size: 15px;">索引</a> <a href="/tags/mybatis/" style="font-size: 15px;">mybatis</a> <a href="/tags/WEB/" style="font-size: 15px;">WEB</a> <a href="/tags/短地址/" style="font-size: 15px;">短地址</a> <a href="/tags/哈希/" style="font-size: 15px;">哈希</a> <a href="/tags/rocketmq/" style="font-size: 15px;">rocketmq</a> <a href="/tags/springboot/" style="font-size: 15px;">springboot</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/Hashmap/" style="font-size: 15px;">Hashmap</a> <a href="/tags/哈希冲突/" style="font-size: 15px;">哈希冲突</a> <a href="/tags/SpringBoot/" style="font-size: 15px;">SpringBoot</a> <a href="/tags/热部署/" style="font-size: 15px;">热部署</a> <a href="/tags/Reentrantlock/" style="font-size: 15px;">Reentrantlock</a> <a href="/tags/内存模型/" style="font-size: 15px;">内存模型</a> <a href="/tags/内存可见性/" style="font-size: 15px;">内存可见性</a> <a href="/tags/指令重排序/" style="font-size: 15px;">指令重排序</a> <a href="/tags/ConcurrentHashMap/" style="font-size: 15px;">ConcurrentHashMap</a> <a href="/tags/注解/" style="font-size: 15px;">注解</a> <a href="/tags/Spring/" style="font-size: 15px;">Spring</a> <a href="/tags/AOP/" style="font-size: 15px;">AOP</a> <a href="/tags/动态代理/" style="font-size: 15px;">动态代理</a> <a href="/tags/IoC/" style="font-size: 15px;">IoC</a> <a href="/tags/Spring-Cloud/" style="font-size: 15px;">Spring Cloud</a> <a href="/tags/Eureka/" style="font-size: 15px;">Eureka</a> <a href="/tags/服务治理/" style="font-size: 15px;">服务治理</a> <a href="/tags/反射/" style="font-size: 15px;">反射</a> <a href="/tags/Ribbon/" style="font-size: 15px;">Ribbon</a> <a href="/tags/泛型/" style="font-size: 15px;">泛型</a> <a href="/tags/Mybatis/" style="font-size: 15px;">Mybatis</a> <a href="/tags/InnoDB/" style="font-size: 15px;">InnoDB</a> <a href="/tags/Git/" style="font-size: 15px;">Git</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/08/27/algorithm-basic/">算法-常见算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/09/notebook-mysql-inside-innodb-engine/">读书笔记-MySQL技术内幕（1）</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/08/tool-gitflow/">GitFlow</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/07/springcloud-ribbon/">Spring Cloud - Ribbon</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/06/springcloud-eureka/">Spring Cloud - Eureka</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/05/spring-ioc-inside/">Spring-IoC原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/spring-ioc-advanced/">Spring-IoC进阶</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/31/mybatis-aop/">Mybatis动态代理原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/29/java-basic-generic/">Java基础-泛型</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/28/java-basic-proxy/">Java基础-动态代理</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://github.com/waterlu" title="waterlu's github" target="_blank">waterlu's github</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">Waterlu's Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>