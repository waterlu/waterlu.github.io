<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="个人技术博客"><title>Spring-IoC | Waterlu's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Spring-IoC</h1><a id="logo" href="/.">Waterlu's Blog</a><p class="description">以铜为鉴，可正衣冠；以史为鉴，可知兴替；以人为鉴，可明得失。</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Spring-IoC</h1><div class="post-meta">May 22, 2018<span> | </span><span class="category"><a href="/categories/Spring/">Spring</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#IoC概述"><span class="toc-number">1.</span> <span class="toc-text">IoC概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#面向接口编程"><span class="toc-number">1.1.</span> <span class="toc-text">面向接口编程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IoC使用"><span class="toc-number">2.</span> <span class="toc-text">IoC使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Bean配置"><span class="toc-number">2.1.</span> <span class="toc-text">Bean配置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#XML配置"><span class="toc-number">2.1.1.</span> <span class="toc-text">XML配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#注解配置"><span class="toc-number">2.1.2.</span> <span class="toc-text">注解配置</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#注解"><span class="toc-number">2.1.2.1.</span> <span class="toc-text">注解</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#例子"><span class="toc-number">2.1.2.2.</span> <span class="toc-text">例子</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java配置"><span class="toc-number">2.1.3.</span> <span class="toc-text">Java配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#选择"><span class="toc-number">2.1.4.</span> <span class="toc-text">选择</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SpringBoot"><span class="toc-number">2.2.</span> <span class="toc-text">SpringBoot</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SpringBootApplication"><span class="toc-number">2.2.1.</span> <span class="toc-text">@SpringBootApplication</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#高级使用"><span class="toc-number">2.3.</span> <span class="toc-text">高级使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#初始化"><span class="toc-number">2.3.1.</span> <span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Scope"><span class="toc-number">2.3.2.</span> <span class="toc-text">@Scope</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Profile"><span class="toc-number">2.3.3.</span> <span class="toc-text">@Profile</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Value"><span class="toc-number">2.3.4.</span> <span class="toc-text">@Value</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ImportResource"><span class="toc-number">2.3.5.</span> <span class="toc-text">@ImportResource</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ApplicationContextAware"><span class="toc-number">2.3.6.</span> <span class="toc-text">ApplicationContextAware</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BeanPostProcessor"><span class="toc-number">2.3.7.</span> <span class="toc-text">BeanPostProcessor</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BeanFactoryPostProcessor"><span class="toc-number">2.3.8.</span> <span class="toc-text">BeanFactoryPostProcessor</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IoC原理"><span class="toc-number">3.</span> <span class="toc-text">IoC原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Tomcat应用的IoC容器"><span class="toc-number">3.1.</span> <span class="toc-text">Tomcat应用的IoC容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SpringBoot应用的IoC容器"><span class="toc-number">3.2.</span> <span class="toc-text">SpringBoot应用的IoC容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-IoC源码分析"><span class="toc-number">3.3.</span> <span class="toc-text">Spring IoC源码分析</span></a></li></ol></li></ol></div></div><div class="post-content"><h2 id="IoC概述"><a href="#IoC概述" class="headerlink" title="IoC概述"></a>IoC概述</h2><p>IoC（Inversion of Control），顾名思义控制反转，什么是控制反转呢？这里的控制指对象的控制权，包括对象的创建和销毁等操作，控制反转就是对象的创建和销毁本来应该由应用程序自己控制的，现在应用程序把对象的控制权交给了Spring容器来管理，这就是控制反转。</p>
<blockquote>
<p>个人理解：Spring容器成为Bean对象的代理或中介。</p>
</blockquote>
<p>经常与Ioc一起出现的还有DI（Dependency Injection）依赖注入。依赖注入的意思是应用程序需要的对象是依赖于Spring容器注入的，不是自己创建的。看上去和IoC是一个意思，个人理解DI是具体实现IoC的一种方法，通过依赖Spring容器注入对象的方式实现了应用程序把对象的控制权转交给了Spring容器。</p>
<blockquote>
<p>如果用租房来比喻，常规方式就是租户自己联系房东租房，IoC就是租户把找房子这件事代理给中介来完成，DI就是中介会帮租户找好房子，租户直接入住就好。（IoC还有可能是中介帮租户联系房东，租户一个一个看房，DI就是租户完全授权给中介，中介直接帮他定一个）。</p>
</blockquote>
<h3 id="面向接口编程"><a href="#面向接口编程" class="headerlink" title="面向接口编程"></a>面向接口编程</h3><p>自己管理对象不是很好吗，为什么要使用IoC，把控制权交给Spring容器呢？</p>
<p>我理解，目的当然是解耦合。对象由Spring容器管理意味着应用程序不必依赖固定的Bean对象，就像租房只要找到满足条件的房子即可，不必非要指定一套房子，这就是解耦合。因此可以得出结论：面向接口编程是IoC的基础，如果应用程序声明注入是实体类，那么还是强耦合的；所以通常应用程序声明注入的都是接口，这才能发挥Spring IoC的作用。</p>
<p>例如：注入UserService接口后可以方便的切换实现类以实现不同的目标。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceMemoryImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// @Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceDatabaseImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应用程序使用时声明注入的是接口，具体实现可以通过打开和关闭@Component注解切换</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">UserService userService;</span><br></pre></td></tr></table></figure>
<p>注入Bean通常有两种方式：byType和byName，按照类型注入或者按照名字注入。按照类型注入是典型的面向接口编程思想，byType时一般class类型为接口，容器负责查找实现了接口的Bean对象。</p>
<h2 id="IoC使用"><a href="#IoC使用" class="headerlink" title="IoC使用"></a>IoC使用</h2><h3 id="Bean配置"><a href="#Bean配置" class="headerlink" title="Bean配置"></a>Bean配置</h3><p>既然Spring容器负责管理类对象，那么它就得知道哪些类对象需要被管理。随着Spring的发展，配置bean对象的方法也在变化，可以使用XML配置文件，也可以使用注解或者JavaConfig，下面我们就来看一下配置方式的进化过程。</p>
<h4 id="XML配置"><a href="#XML配置" class="headerlink" title="XML配置"></a>XML配置</h4><p>把需要创建的对象（Spring称之为Bean）定义在一个xml文件里面，每个bean指定ID和对应类。IoC容器读取这个xml文件，通过反射创建类对象，通过ID返回类对象。Bean里面可以通过property属性显式定义bean的依赖，也可以不定义，让Spring完成自动配置。</p>
<p>例如：配置/resources/spring-context.xml如下：定义了car和wheel两个bean，car依赖wheel</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"car"</span> <span class="attr">class</span>=<span class="string">"cn.lu.spring.ioc.Car"</span> <span class="attr">scope</span>=<span class="string">"singleton"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--constructor-arg ref="wheel" /--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"wheel"</span> <span class="attr">ref</span>=<span class="string">"wheel"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"wheel"</span> <span class="attr">class</span>=<span class="string">"cn.lu.spring.ioc.Wheel"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Bean对象如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Wheel wheel;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWheel</span><span class="params">(Wheel wheel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.wheel = wheel;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wheel</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：这里Car类必须实现setWheel()方法。</p>
</blockquote>
<p>使用如下：</p>
<ul>
<li>ApplicationContext类可以理解为IoC容器，ClassPathXmlApplicationContext类是从classpath目录读取XML文件来解析Bean的IoC容器实现；</li>
<li>调用容器类的getBean()方法就可以从容器中获取Bean对象了，传入的参数可以是ID，也可以是类名；</li>
<li>Bean对象之间的依赖关系可以在XML中定义bean时通过property属性设置，相当于调用set方法，也可以使用constructor-arg设置，相当于在构造函数中传入依赖对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(BlockJUnit4ClassRunner.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IoCTest</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> ApplicationContext context;</span><br><span class="line">  <span class="meta">@Before</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"classpath:spring-context.xml"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Car car = (Car)context.getBean(<span class="string">"car"</span>);</span><br><span class="line">    <span class="comment">// Car car = context.getBean(Car.class);</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上这种用法非常好理解，ApplicationContext类读取XML文件并构造Bean对象，通过getBean()返回对象，ApplicationContext类就是IoC容器。容器需要做的就是解析XML文件，通过反射构造对象。</p>
<blockquote>
<p>以上方法实际上没有实现依赖注入，需要自己主动获取。</p>
</blockquote>
<h4 id="注解配置"><a href="#注解配置" class="headerlink" title="注解配置"></a>注解配置</h4><p>如上所述，我们需要把所有用到的bean对象都定义在xml文件中，xml文件将越来越庞大。Spring 2.5以后出现了注解方式，使用注解意味着将集中的bean配置（xml文件）分散到各个bean对象中。个人觉得没有两种用法没有好坏之分。</p>
<h5 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h5><p>@Component注解起到XML文件中<code>&lt;bean/&gt;</code> 一样的作用，下面两种写法是等同的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span>(<span class="string">"car"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"car"</span> <span class="attr">class</span>=<span class="string">"Car"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>@Component注解的value属性等同于bean的id属性，@Component的value默认值为首字母小写的类名，一般可以省略。从@Component又衍生出@Controller、@Service和@Repository注解，用在不同层，本质是一样的。</p>
<p>@Autowired/@Resource注解起到XML文件中&lt;bean.property&gt;和&lt;bean.constructor-arg&gt;的作用，@Autowired注解可以修饰类的成员变量，也可以修饰类的构造函数和成员方法。</p>
<p>@Autowired和@Resource的区别：</p>
<ul>
<li>@Autowired默认通过bean的类型注入；</li>
<li>@Resource默认通过bean的名字注入。</li>
</ul>
<p>引入@Autowired注解后真正实现了依赖注入，当我们需要使用一个对象时，直接将其声明为@Autowired，容器负责帮我们构造这个对象的实例。@Autowired注解默认是按照类型构造的，也就是说容器负责查找实现类并通过反射进行构造，所以通常@Autowired注解修饰的是接口。</p>
<p>进一步思考一下，如果一个@Autowired注解修饰的接口有多个实现类，那么容器就不知道应该构造哪个类了，怎么办？这个时候我们可以增加@Qualifier注解来指定bean的名称。下面以UserService为例，有UserServiceMemoryImpl和UserServiceDatabaseImpl两个实现类，实现选择数据库实现，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier</span>(<span class="string">"userServiceDatabaseImpl"</span>)</span><br><span class="line">UserService userService;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>因为@Component默认bean名称为首字母小写的类名，所以可以使用userServiceDatabaseImpl，如果UserServiceDatabaseImpl在@Component中自定义了bean名称，那么要使用自定义的。</p>
</blockquote>
<h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><p>引入注解后需要增加一个新的配置，就是到哪里去查找注解，所以使用注解后的xml配置文件如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"cn.lu.spring.ioc"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Bean对象如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> Wheel wheel;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wheel</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：这里Car类不用实现setWheel()方法就可以注入wheel，这和反射的实现有关。</p>
</blockquote>
<p>使用如下：我们通过@Autowired注解直接注入Car对象，这才是真正的依赖注入。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class)</span><br><span class="line"><span class="meta">@ContextConfiguration</span>(locations = &#123;<span class="string">"spring-context.xml"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IoCTest</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> Car car;</span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAnnotation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    logger.info(car.toString());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：这里我们没有显式创建ApplicationContext，是 @Runwith(SpringJUnit4ClassRunner.class)和@ContextConfiguration起了相同的作用。</p>
<h4 id="Java配置"><a href="#Java配置" class="headerlink" title="Java配置"></a>Java配置</h4><p>从Spring 3.0开始提供了Java Config也叫做Java配置，Spring Boot建议使用Java配置替代XML配置。</p>
<p>Java配置引入了@Configuration、@Bean、@ImportResource和@Value等注解。</p>
<p>@Configuration注解就相当于一个xml文件，@Bean注解就相当于xml文件中的一个<code>&lt;bean/&gt;</code>  ，@ComponentScan注解相当于xml文件中的<code>&lt;context:component-scan /&gt;</code> 。</p>
<p>例如：Java配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Config</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Wheel <span class="title">wheel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Wheel();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Car <span class="title">car</span><span class="params">(Wheel wheel)</span> </span>&#123;</span><br><span class="line">    Car car = <span class="keyword">new</span> Car();</span><br><span class="line">    car.setWheel(wheel);</span><br><span class="line">    <span class="keyword">return</span> car;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>等同于如下xml配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"wheel"</span> <span class="attr">class</span>=<span class="string">"cn.lu.spring.ioc.Wheel"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"car"</span> <span class="attr">class</span>=<span class="string">"cn.lu.spring.ioc.Car"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"wheel"</span> <span class="attr">ref</span>=<span class="string">"wheel"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>使用时和前面基本一样，只需要把@ContextConfiguration配置的xml文件替换为class类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class)</span><br><span class="line"><span class="meta">@ContextConfiguration</span>(classes = &#123;Config.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IoCTestWithJavaConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h4><p>现在我们有三种方法定义一个Bean，选择哪一个呢？</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"car"</span> <span class="attr">class</span>=<span class="string">"cn.lu.spring.ioc.Car"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaConfiguratoin</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Car <span class="title">car</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Car();</span><br><span class="line">  &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>习惯上，我们使用第二种方法@Component注解（实际更多使用@Controller、@Service等注解）来配置我们的业务Bean，XML不再使用，Java配置用来完成非业务Bean的配置。</p>
<blockquote>
<p>个人理解：@Component注解是侵入式的，XML和Java配置是不需要侵入源代码的，这是他们的优势。</p>
</blockquote>
<h3 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h3><p>下面看看在SpringBoot中如何使用IoC管理Bean对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceDemoApplication</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  UserService userService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子代码展示了最常见的用法：</p>
<ul>
<li>Spring容器扫描到@Service注解后创建UserServiceImpl类实例对象；</li>
<li>Spring容器扫描到@Controller注解后创建UserController类实例对象；</li>
<li>Spring容器扫描到@Autowired注解后将UserServiceImpl类实例对象注入到UserController类实例对象的userService属性中。</li>
</ul>
<p>上面过程很好理解，但仔细一想你会发现代码中没有出现@ComponentScan注解，Spring容器怎么知道去哪里扫描注解呢？还有，容器类ApplicationContext是如何创建的呢？</p>
<h4 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</h4><p>问题的答案就在@SpringBootApplication注解中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(excludeFilters = &#123;</span><br><span class="line">		<span class="meta">@Filter</span>(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span><br><span class="line">		<span class="meta">@Filter</span>(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootConfiguration &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@SpringBootApplication注解组合了@Configuration、@ComponentScan和@EnableAutoConfiguration三个最重要的注解，所以拥有了它们的功能。</p>
<p>我们知道一个@Configuration类文件对应一个XML配置文件，所以当Spring扫描到@Configuration注解后就会创建ApplicationContext容器类，并扫描@Component注解创建Bean对象放入容器类中。</p>
<p>@ComponentScan注解默认扫描当前包及其子目录下的源代码，所以Application类通常都是放在包的最外层，这样才可以保证web/service等目录下的注解可以被扫描到。</p>
<p>例如：新建应用在com.test.demo包下，引用的common项目在com.test.common包下，那么common项目中的@Component等注解是不生效的，因为Spring没有扫描它们。如果希望common包下的注解也生效，需要显式配置scanBasePackages，样例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span>(scanBasePackages = &#123;<span class="string">"com.test.demo"</span>, <span class="string">"com.test.common"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>@EnableAutoConfiguration是SpringBoot特性，和IoC无关，这里不展开。</p>
</blockquote>
<h3 id="高级使用"><a href="#高级使用" class="headerlink" title="高级使用"></a>高级使用</h3><p>前面介绍了IoC的最基本用法，帮助我们的应用程序创建类实例对象，下面看看其他用法。</p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>实际开发中，有时需要在Bean对象创建后和销毁前做一些操作，可以使用下面两个注解：</p>
<ul>
<li>@PostConstruct，在构造函数完成之后执行；</li>
<li>@PreDestroy，在析构函数执行之前执行；</li>
</ul>
<p>除了使用@PostConstruct注解，还可以实现InitializingBean接口和afterPropertiesSet()方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">UserController</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"UserController()"</span>);</span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="meta">@PostConstruct</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postConstruct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"UserController @PostConstruct"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@PreDestroy</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"UserController @PreDestroy"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"UserController afterPropertiesSet"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码的输出日志顺序为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">UserController()</span><br><span class="line">UserController @PostConstruct</span><br><span class="line">UserController afterPropertiesSet</span><br><span class="line">UserController @PreDestroy</span><br></pre></td></tr></table></figure>
<h4 id="Scope"><a href="#Scope" class="headerlink" title="@Scope"></a>@Scope</h4><p>常用的Scope有两种：Singleton和Prototyp，默认是Singleton：</p>
<ul>
<li>Singleton，一个容器只创建一个Bean实例，每次getBean()都返回相同的实例；</li>
<li>Prototyp，每次getBean()都新创建一个Bean实例；</li>
<li>Session，每个HTTP Session创建一个Bean实例。</li>
</ul>
<blockquote>
<p>注意：Singleton强调一个容器只有一个Bean实例，不同容器可以有不同Bean实例。</p>
</blockquote>
<h4 id="Profile"><a href="#Profile" class="headerlink" title="@Profile"></a>@Profile</h4><p>@Profile注解为我们提供了在不同环境下创建不同Bean实例的能力。</p>
<p>一般用在配置类中，例如：生产环境MySQL和Redis需要使用集群配置，开发和测试环境使用单点配置就好了，这两种情况下的配置可能是不同的，这个时候@Profile就派上用场了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DatabaseConfig</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="meta">@Profile</span>(<span class="string">"dev"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> DataSource <span class="title">getDevDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DevDataSource();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="meta">@Profile</span>(<span class="string">"prod"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> DataSource <span class="title">getProdDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ProdDataSource();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">DataSource dataSource;</span><br></pre></td></tr></table></figure>
<p>DataSource是接口，DevDataSource和ProdDataSource是具体实现，根据运行环境的不同返回不同的实现。运行环境通过配置application.properties切换。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.profiles.active=dev</span><br></pre></td></tr></table></figure>
<h4 id="Value"><a href="#Value" class="headerlink" title="@Value"></a>@Value</h4><p>使用@Value注解可以注入属性值，最常见的是从application.properties中读取配置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;book.name&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String bookName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>@Value(&quot;${book.name}&quot;)</code> 表示读取配置文件中<code>book.name</code> 的值，application.properties配置如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">book.name=Spring</span><br></pre></td></tr></table></figure>
<p>不要忘了@Component注解，只有Spring容器管理的Bean才可以使用@Value注解。</p>
<p>使用@Value注解还可以读取其他Bean的属性 ，例如：以下代码从company这个Bean中读取name字段并赋值到Book的bookPub字段，和前面的区别是<code>$</code>换成了<code>#</code> 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"#&#123;company.name&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String bookPub;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ImportResource"><a href="#ImportResource" class="headerlink" title="@ImportResource"></a>@ImportResource</h4><p>使用@ImportResource注解可以直接导入xml配置文件，这是从xml配置到java配置过渡的最简单方案。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ImportResource</span>(locations=&#123;<span class="string">"classpath:applicationContext.xml"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XmlConfiguration</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ApplicationContextAware"><a href="#ApplicationContextAware" class="headerlink" title="ApplicationContextAware"></a>ApplicationContextAware</h4><p>有时候我们需要读取容器中的其他类实例对象，例如：自定义注解后，需要扫描注解来实现自定义逻辑。以下以RocketMQ自定义的@RocketMQProduer注解为例：</p>
<ul>
<li>实现ApplicationContextAware接口的setApplicationContext()方法获得容器；</li>
<li>在构造函数完成后调用ApplicationContext的getBeansWithAnnotation()方法获得所有声明了@RocketMQProducer注解的类实例对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MQProducerAutoConfiguration</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> ApplicationContext applicationContext;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.applicationContext = applicationContext;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@PostConstruct</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; beans = <span class="keyword">null</span>;</span><br><span class="line">    beans = applicationContext.getBeansWithAnnotation(RocketMQProducer.class);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a>BeanPostProcessor</h4><h4 id="BeanFactoryPostProcessor"><a href="#BeanFactoryPostProcessor" class="headerlink" title="BeanFactoryPostProcessor"></a>BeanFactoryPostProcessor</h4><h2 id="IoC原理"><a href="#IoC原理" class="headerlink" title="IoC原理"></a>IoC原理</h2><h3 id="Tomcat应用的IoC容器"><a href="#Tomcat应用的IoC容器" class="headerlink" title="Tomcat应用的IoC容器"></a>Tomcat应用的IoC容器</h3><p>早期Spring经常和Tomcat一起使用，使用的是XML配置，但我们并没有像前面例子代码那样显式调用<code>new ClassPathXmlApplicationContext()</code>  ，那么Tomcat是如何创建Spring的IoC容器的呢？</p>
<p>答案就在webapp/WEB-INF/web.xml中，关键点就是ContextLoaderListener</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Tomcat中使用的是ApplicationContext的另外一个子类WebApplicationContext，ContextLoaderListener是Tomcat的一个ServletContext，当它初始化的时候创建WebApplicationContext容器类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.web.context;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletContextListener;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextLoaderListener</span> <span class="keyword">extends</span> <span class="title">ContextLoader</span> <span class="keyword">implements</span> <span class="title">ServletContextListener</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.initWebApplicationContext(event.getServletContext());</span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextDestroyed</span><span class="params">(ServletContextEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.closeWebApplicationContext(event.getServletContext());</span><br><span class="line">    ContextCleanupListener.cleanupAttributes(event.getServletContext());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当Servelt容器启动时触发contextInitialized()方法，它执行基类ContextLoader的方法来构造容器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.web.context;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextLoader</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> WebApplicationContext context;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> WebApplicationContext <span class="title">initWebApplicationContext</span><span class="params">(ServletContext servletContext)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.context == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.context = <span class="keyword">this</span>.createWebApplicationContext(servletContext);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.context;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里可以看到最终调用createWebApplicationContext()方法返回WebApplicationContext类实例对象，这就是Tomcat中的IoC容器。后面的操作大家都了解了，WebApplicationContext容器负责管理Bean对象。</p>
<h3 id="SpringBoot应用的IoC容器"><a href="#SpringBoot应用的IoC容器" class="headerlink" title="SpringBoot应用的IoC容器"></a>SpringBoot应用的IoC容器</h3><p>我们再来看看目前流行的SpringBoot是如何创建Spring的IoC容器的。</p>
<p>SpringBoot其实更好理解一点，我们从程序入口开始看</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringbootApplication</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SpringApplication.run(SpringbootApplication.class, args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>入口是SpringApplication的run()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.boot;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringApplication</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">    ConfigurableApplicationContext context = <span class="keyword">null</span>;</span><br><span class="line">    context = <span class="keyword">this</span>.createApplicationContext();</span><br><span class="line">    <span class="keyword">this</span>.refreshContext(context);</span><br><span class="line">    <span class="keyword">return</span> context;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里只截取了和IoC相关代码，可以看到run()方法中创建了context容器，并调用refreshContext()方法加载Bean对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.boot;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringApplication</span> </span>&#123;   </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> webEnvironment;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> ConfigurableApplicationContext <span class="title">createApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; contextClass = <span class="keyword">this</span>.applicationContextClass;</span><br><span class="line">    <span class="keyword">if</span>(contextClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.webEnvironment) &#123;</span><br><span class="line">        contextClass = Class.forName(<span class="string">"AnnotationConfigEmbeddedWebApplicationContext"</span>); </span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        contextClass = Class.forName(<span class="string">"AnnotationConfigApplicationContext"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (ConfigurableApplicationContext)BeanUtils.instantiate(contextClass);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>类名太长，这里省略了包名。</p>
</blockquote>
<p>由于我们大部分是web应用，所以使用的是AnnotationConfigEmbeddedWebApplicationContext，从名字上可以看出，这个ApplicationContext（容器）是基于注解创建的，支持嵌入式web应用。</p>
<h3 id="Spring-IoC源码分析"><a href="#Spring-IoC源码分析" class="headerlink" title="Spring IoC源码分析"></a>Spring IoC源码分析</h3><p>入口是AbstractApplicationContext的refresh()方法，我们从这里开始。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.context.support;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractApplicationContext</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">      <span class="comment">// 创建BeanFactory</span></span><br><span class="line">      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">      postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">      invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">      registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 实例化Bean</span></span><br><span class="line">      finishBeanFactoryInitialization(beanFactory);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最重要的两个方法是obtainFreshBeanFactory()和finishBeanFactoryInitialization()，前者读取Bean相关配置信息，后者创建Bean实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.context.support;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractApplicationContext</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title">obtainFreshBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    refreshBeanFactory();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.beanFactory;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.context.support;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractRefreshableApplicationContext</span> <span class="keyword">extends</span> <span class="title">AbstractApplicationContext</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    DefaultListableBeanFactory beanFactory = createBeanFactory();</span><br><span class="line">    loadBeanDefinitions(beanFactory);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanFactoryMonitor) &#123;</span><br><span class="line">      <span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.beans.factory.support;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultListableBeanFactory</span> <span class="keyword">extends</span> <span class="title">AbstractBeanFactory</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, BeanDefinition&gt; beanDefinitionMap = <span class="keyword">new</span> </span><br><span class="line">    ConcurrentHashMap&lt;String, BeanDefinition&gt;(<span class="number">256</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以XML配置为例，AbstractApplicationContext类的子类AbstractXmlApplicationContext实现了loadBeanDefinitions()方法，完成加载和解析XML文件的操作，并将BeanDefinition信息放入到BeanFactory中。其中，BeanDefinition与XML文件中的一个<code>&lt;bean /&gt;</code> 相对应，BeanFactory接口的默认实现类是DefaultListableBeanFactory，可以看到DefaultListableBeanFactory中使用ConcurrentHashMap来保存Bean信息。</p>
<p>这就完成了第一步工作，解析XML文件读取配置信息到BeanFactory的Map中保存。</p>
<p>接下来看看如何根据上面的信息实例化对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.context.support;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractApplicationContext</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Stop using the temporary ClassLoader for type matching.</span></span><br><span class="line">    beanFactory.setTempClassLoader(<span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// Allow for caching all bean definition metadata, not expecting further changes.</span></span><br><span class="line">    beanFactory.freezeConfiguration();</span><br><span class="line">    <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">    beanFactory.preInstantiateSingletons();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>AbstractApplicationContext调用BeanFactory的方法来实例化对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.beans.factory.support;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultListableBeanFactory</span> <span class="keyword">extends</span> <span class="title">AbstractBeanFactory</span> </span>&#123;	</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    List&lt;String&gt; beanNames = <span class="keyword">new</span> ArrayList&lt;String&gt;(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line">    <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">      getBean(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> doGetBean(name, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.beans.factory.support;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractBeanFactory</span> <span class="keyword">implements</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(<span class="keyword">final</span> String name, <span class="keyword">final</span> Class&lt;T&gt; requiredType, </span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">final</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">    <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">      sharedInstance = getSingleton(beanName, <span class="keyword">new</span> ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            destroySingleton(beanName);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line">      <span class="comment">// It's a prototype -&gt; create a new instance.</span></span><br><span class="line">      Object prototypeInstance = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        beforePrototypeCreation(beanName);</span><br><span class="line">        prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">finally</span> &#123;</span><br><span class="line">        afterPrototypeCreation(beanName);</span><br><span class="line">      &#125;</span><br><span class="line">      bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (T) bean;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DefaultListableBeanFactory类的getBean()方法会调用AbstractBeanFactory类的doGetBean()方法，里面通过createBean()方法创建实例对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.beans.factory.support;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAutowireCapableBeanFactory</span> <span class="keyword">extends</span> <span class="title">AbstractBeanFactory</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> Object <span class="title">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, Object[] args)</span> </span>&#123;</span><br><span class="line">	Object beanInstance = doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">    <span class="keyword">return</span> beanInstance;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, </span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">final</span> Object[] args)</span> </span>&#123;</span><br><span class="line">      BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line">    instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">    <span class="keyword">final</span> Object bean = instanceWrapper.getWrappedInstance();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">createBeanInstance</span><span class="params">(String beanName, RootBeanDefinition mbd,</span></span></span><br><span class="line"><span class="function"><span class="params">                                           Object[] args)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">instantiateBean</span><span class="params">(<span class="keyword">final</span> String beanName, </span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">final</span> RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AbstractAutowireCapableBeanFactory类的createBean()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.beans.factory.support;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleInstantiationStrategy</span> <span class="keyword">implements</span> <span class="title">InstantiationStrategy</span> </span>&#123;</span><br><span class="line">  	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">instantiate</span><span class="params">(RootBeanDefinition bd, String beanName, BeanFactory owner)</span> </span>&#123;</span><br><span class="line">      Constructor&lt;?&gt; ctor =	clazz.getDeclaredConstructor((Class[]) <span class="keyword">null</span>);</span><br><span class="line">      ctor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">      <span class="keyword">return</span> ctor.newInstance(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.beans.factory.support;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAutowireCapableBeanFactory</span> <span class="keyword">extends</span> <span class="title">AbstractBeanFactory</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">populateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, BeanWrapper bw)</span> </span>&#123;</span><br><span class="line">    applyPropertyValues(beanName, mbd, bw, pvs);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">applyPropertyValues</span><span class="params">(String beanName, BeanDefinition mbd, BeanWrapper bw,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     PropertyValues pvs)</span> </span>&#123;</span><br><span class="line">    MutablePropertyValues mpvs = <span class="keyword">null</span>;</span><br><span class="line">    List&lt;PropertyValue&gt; original;</span><br><span class="line">    <span class="keyword">for</span> (PropertyValue pv : original) &#123;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">    bw.setPropertyValues(<span class="keyword">new</span> MutablePropertyValues(deepCopy));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.beans;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanWrapperImpl</span> <span class="keyword">implements</span> <span class="title">BeanWrapper</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanPropertyHandler</span> <span class="keyword">extends</span> <span class="title">PropertyHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PropertyDescriptor pd;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">final</span> Object object, Object valueToApply)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> Method writeMethod = (<span class="keyword">this</span>.pd <span class="keyword">instanceof</span> GenericTypeAwarePropertyDescriptor ?</span><br><span class="line">                                  ((GenericTypeAwarePropertyDescriptor) <span class="keyword">this</span>.pd).getWriteMethodForActualAccess() :</span><br><span class="line">                                  <span class="keyword">this</span>.pd.getWriteMethod());</span><br><span class="line">      <span class="keyword">if</span> (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) &amp;&amp; !writeMethod.isAccessible()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">          AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              writeMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          writeMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">final</span> Object value = valueToApply;</span><br><span class="line">      <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedExceptionAction&lt;Object&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">              writeMethod.invoke(object, value);</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, acc);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (PrivilegedActionException ex) &#123;</span><br><span class="line">          <span class="keyword">throw</span> ex.getException();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        writeMethod.invoke(getWrappedInstance(), value);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;      </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://www.jianshu.com/p/1417eefd2ab1" target="_blank" rel="noopener">Spring探秘|妙用BeanPostProcessor</a></p>
</div><div class="tags"><a href="/tags/Spring/">Spring</a><a href="/tags/IoC/">IoC</a></div><div class="post-nav"><a class="pre" href="/2018/05/27/spring-aop/">Spring-AOP</a><a class="next" href="/2018/05/21/knowledge-thread/">【置顶】Java多线程一篇就够</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JAVA/">JAVA</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpringBoot/">SpringBoot</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/WEB/">WEB</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/分布式/">分布式</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/工具/">工具</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/并发编程/">并发编程</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/消息队列/">消息队列</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/">设计模式</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/mq/" style="font-size: 15px;">mq</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/github/" style="font-size: 15px;">github</a> <a href="/tags/并发/" style="font-size: 15px;">并发</a> <a href="/tags/线程/" style="font-size: 15px;">线程</a> <a href="/tags/线程池/" style="font-size: 15px;">线程池</a> <a href="/tags/任务调度/" style="font-size: 15px;">任务调度</a> <a href="/tags/排队策略/" style="font-size: 15px;">排队策略</a> <a href="/tags/饱和策略/" style="font-size: 15px;">饱和策略</a> <a href="/tags/多线程/" style="font-size: 15px;">多线程</a> <a href="/tags/synchronized/" style="font-size: 15px;">synchronized</a> <a href="/tags/wait/" style="font-size: 15px;">wait</a> <a href="/tags/notify/" style="font-size: 15px;">notify</a> <a href="/tags/单例/" style="font-size: 15px;">单例</a> <a href="/tags/线程安全/" style="font-size: 15px;">线程安全</a> <a href="/tags/Database/" style="font-size: 15px;">Database</a> <a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/Sharding/" style="font-size: 15px;">Sharding</a> <a href="/tags/分布式/" style="font-size: 15px;">分布式</a> <a href="/tags/SnowFlake/" style="font-size: 15px;">SnowFlake</a> <a href="/tags/索引/" style="font-size: 15px;">索引</a> <a href="/tags/rocketmq/" style="font-size: 15px;">rocketmq</a> <a href="/tags/Hashmap/" style="font-size: 15px;">Hashmap</a> <a href="/tags/哈希冲突/" style="font-size: 15px;">哈希冲突</a> <a href="/tags/WEB/" style="font-size: 15px;">WEB</a> <a href="/tags/短地址/" style="font-size: 15px;">短地址</a> <a href="/tags/哈希/" style="font-size: 15px;">哈希</a> <a href="/tags/hashCode/" style="font-size: 15px;">hashCode</a> <a href="/tags/mybatis/" style="font-size: 15px;">mybatis</a> <a href="/tags/springboot/" style="font-size: 15px;">springboot</a> <a href="/tags/ConcurrentHashMap/" style="font-size: 15px;">ConcurrentHashMap</a> <a href="/tags/Reentrantlock/" style="font-size: 15px;">Reentrantlock</a> <a href="/tags/SpringBoot/" style="font-size: 15px;">SpringBoot</a> <a href="/tags/热部署/" style="font-size: 15px;">热部署</a> <a href="/tags/Spring/" style="font-size: 15px;">Spring</a> <a href="/tags/IoC/" style="font-size: 15px;">IoC</a> <a href="/tags/注解/" style="font-size: 15px;">注解</a> <a href="/tags/反射/" style="font-size: 15px;">反射</a> <a href="/tags/动态代理/" style="font-size: 15px;">动态代理</a> <a href="/tags/泛型/" style="font-size: 15px;">泛型</a> <a href="/tags/内存模型/" style="font-size: 15px;">内存模型</a> <a href="/tags/内存可见性/" style="font-size: 15px;">内存可见性</a> <a href="/tags/指令重排序/" style="font-size: 15px;">指令重排序</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/05/29/java-basic-generic/">Java基础-泛型</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/28/java-basic-proxy/">Java基础-动态代理</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/28/java-basic-annotation/">Java基础-注解</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/28/java-basic-reflect/">Java基础-反射</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/27/spring-aop/">Spring-AOP</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/22/spring-ioc/">Spring-IoC</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/21/knowledge-thread/">【置顶】Java多线程一篇就够</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/18/springboot-devtool-deploy/">SpringBoot热部署</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/17/thread-java-concurrent-sourcecode/">并行包源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/16/thread-basic-java-concurrent/">Java并行包</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://github.com/waterlu" title="waterlu's github" target="_blank">waterlu's github</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">Waterlu's Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>