<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="个人技术博客"><title>Spring-IoC | Waterlu's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Spring-IoC</h1><a id="logo" href="/.">Waterlu's Blog</a><p class="description">以铜为鉴，可正衣冠；以史为鉴，可知兴替；以人为鉴，可明得失。</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Spring-IoC</h1><div class="post-meta">May 22, 2018<span> | </span><span class="category"><a href="/categories/Spring/">Spring</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><a class="disqus-comment-count" href="/2018/05/22/spring-ioc/#vcomment"><span class="valine-comment-count" data-xid="/2018/05/22/spring-ioc/"></span><span> 条评论</span></a><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#IoC概述"><span class="toc-number">1.</span> <span class="toc-text">IoC概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#面向接口编程"><span class="toc-number">1.1.</span> <span class="toc-text">面向接口编程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IoC使用"><span class="toc-number">2.</span> <span class="toc-text">IoC使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#配置Bean对象"><span class="toc-number">2.1.</span> <span class="toc-text">配置Bean对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#XML配置"><span class="toc-number">2.1.1.</span> <span class="toc-text">XML配置</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#bean标签"><span class="toc-number">2.1.1.1.</span> <span class="toc-text">bean标签</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#scope"><span class="toc-number">2.1.1.2.</span> <span class="toc-text">scope</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#import标签"><span class="toc-number">2.1.1.3.</span> <span class="toc-text">import标签</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#读取配置文件"><span class="toc-number">2.1.1.4.</span> <span class="toc-text">读取配置文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#自动装配"><span class="toc-number">2.1.1.5.</span> <span class="toc-text">自动装配</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#注解配置"><span class="toc-number">2.1.2.</span> <span class="toc-text">注解配置</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Component注解"><span class="toc-number">2.1.2.1.</span> <span class="toc-text">@Component注解</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Autowired注解"><span class="toc-number">2.1.2.2.</span> <span class="toc-text">@Autowired注解</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#依赖注入"><span class="toc-number">2.1.2.3.</span> <span class="toc-text">依赖注入</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#component-scan"><span class="toc-number">2.1.2.4.</span> <span class="toc-text">component-scan</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#例子"><span class="toc-number">2.1.2.5.</span> <span class="toc-text">例子</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java配置"><span class="toc-number">2.1.3.</span> <span class="toc-text">Java配置</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Configuration注解"><span class="toc-number">2.1.3.1.</span> <span class="toc-text">@Configuration注解</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ComponentScan注解"><span class="toc-number">2.1.3.2.</span> <span class="toc-text">@ComponentScan注解</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#选择"><span class="toc-number">2.1.4.</span> <span class="toc-text">选择</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SpringBoot"><span class="toc-number">2.2.</span> <span class="toc-text">SpringBoot</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SpringBootApplication"><span class="toc-number">2.2.1.</span> <span class="toc-text">@SpringBootApplication</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ConfigurationProperties"><span class="toc-number">2.2.2.</span> <span class="toc-text">@ConfigurationProperties</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#扩展使用"><span class="toc-number">2.3.</span> <span class="toc-text">扩展使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#初始化"><span class="toc-number">2.3.1.</span> <span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Profile"><span class="toc-number">2.3.2.</span> <span class="toc-text">@Profile</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ImportResource"><span class="toc-number">2.3.3.</span> <span class="toc-text">@ImportResource</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Import"><span class="toc-number">2.3.4.</span> <span class="toc-text">@Import</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IoC容器"><span class="toc-number">3.</span> <span class="toc-text">IoC容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JUnit"><span class="toc-number">3.1.</span> <span class="toc-text">JUnit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Tomcat"><span class="toc-number">3.2.</span> <span class="toc-text">Tomcat</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SpringBoot-1"><span class="toc-number">3.3.</span> <span class="toc-text">SpringBoot</span></a></li></ol></li></ol></div></div><div class="post-content"><h2 id="IoC概述"><a href="#IoC概述" class="headerlink" title="IoC概述"></a>IoC概述</h2><p>IoC（Inversion of Control），顾名思义控制反转，什么是控制反转呢？这里的控制指对象的控制权，包括对象的创建和销毁等操作，控制反转就是对象的创建和销毁本来应该由应用程序自己控制的，现在应用程序把对象的控制权交给了Spring容器来管理，这就是控制反转。</p>
<blockquote>
<p>个人理解：Spring容器成为Bean对象的代理或中介。</p>
</blockquote>
<p>经常与Ioc一起出现的还有DI（Dependency Injection）依赖注入。依赖注入的意思是应用程序需要的对象是依赖于Spring的IoC容器注入的，不是自己创建的。看上去和IoC是一个意思，个人理解DI是具体实现IoC的一种方法，通过依赖IoC容器注入对象的方式实现了应用程序把对象的控制权转交给了IoC容器。除了DI依赖注入实现IoC以外，还可以DL（Dependency  Lookup）主动从IoC容器中读取Bean对象。</p>
<blockquote>
<p>如果用租房来比喻，常规方式就是租户自己找房子，IoC就是租户把找房子这件事交给给中介来完成，DI就是中介找好房子把信息Push给租户，DL就是租户主动从中介Pull房子信息。</p>
</blockquote>
<h3 id="面向接口编程"><a href="#面向接口编程" class="headerlink" title="面向接口编程"></a>面向接口编程</h3><p>自己管理对象不是很好吗，为什么要使用IoC，把控制权交给IoC容器呢？</p>
<p>我理解，目的当然是解耦合。对象由IoC容器管理意味着应用程序不必依赖固定的Bean对象，就像租房只要找到满足条件的房子即可，不必非要指定某一套房子，这就是解耦合。因此可以得出结论：面向接口编程是IoC的基础，如果应用程序声明注入是实体类，那么还是强耦合的；所以通常应用程序声明注入的Bean对象都是接口，这样才能更好发挥IoC的作用。</p>
<p>例如：注入UserService接口后可以方便的切换实现类以实现不同的目标。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceMemoryImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// @Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceDatabaseImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应用程序使用时声明注入的是接口，具体实现类可以通过打开和关闭@Component注解切换，引入方无感知。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">UserService userService;</span><br></pre></td></tr></table></figure>
<p>注入Bean通常有两种方式：byType和byName，按照类型注入或者按照名字注入。按照类型注入是典型的面向接口编程思想，byType时一般class类型为接口，容器负责查找实现了接口的Bean对象。</p>
<h2 id="IoC使用"><a href="#IoC使用" class="headerlink" title="IoC使用"></a>IoC使用</h2><h3 id="配置Bean对象"><a href="#配置Bean对象" class="headerlink" title="配置Bean对象"></a>配置Bean对象</h3><p>既然我们想把管理对象的工作交给IoC容器，那么它就得知道哪些对象需要被管理。随着Spring的发展，告诉IoC容器需要管理哪些Bean对象的方式也在变化，可以使用XML配置文件，也可以使用注解或者JavaConfig。</p>
<h4 id="XML配置"><a href="#XML配置" class="headerlink" title="XML配置"></a>XML配置</h4><p>把需要创建的Bean对象定义在一个xml文件里面，每个bean指定ID和对应类。IoC容器读取这个xml文件，通过反射创建Bean对象，通过ID返回Bean对象。同样，Bean对象之间的依赖关系也通过xml文件来配置。</p>
<h5 id="bean标签"><a href="#bean标签" class="headerlink" title="bean标签"></a>bean标签</h5><p>具体通过bean标签来配置一个Bean对象，通过class属性反射创建，通过id属性引用Bean对象；</p>
<ul>
<li><property ref=""> - 对应Bean对象的属性，形成依赖关系，调用set()方法设置；</property></li>
<li><property value=""> - 也可以通过value属性直接赋值；</property></li>
<li><constructor-arg ref=""> - 对应Bean对象构造函数的参数，形成依赖关系，通过构造函数设置；</constructor-arg></li>
<li>ref - ref就是Reference，引用，值为Bean的id；</li>
</ul>
<p>例如：配置/resources/spring-context.xml如下：定义了car和wheel两个bean，car依赖wheel</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"car"</span> <span class="attr">class</span>=<span class="string">"cn.lu.spring.ioc.Car"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"wheel"</span> <span class="attr">ref</span>=<span class="string">"wheel"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"wheel"</span> <span class="attr">class</span>=<span class="string">"cn.lu.spring.ioc.Wheel"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Bean对象如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Wheel wheel;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWheel</span><span class="params">(Wheel wheel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.wheel = wheel;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wheel</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：这里Car类必须实现setWheel()方法。</p>
</blockquote>
<p>使用如下：</p>
<ul>
<li>ApplicationContext类可以理解为IoC容器，ClassPathXmlApplicationContext类是从classpath目录读取XML文件来解析Bean的IoC容器实现；</li>
<li>调用容器类的getBean()方法就可以从容器中获取Bean对象了，传入的参数可以是ID，也可以是类名。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(BlockJUnit4ClassRunner.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IoCTest</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> ApplicationContext context;</span><br><span class="line">  <span class="meta">@Before</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"classpath:spring-bean.xml"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Car car = context.getBean(Car.class);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上这种用法非常好理解，ApplicationContext类读取XML文件并构造Bean对象，通过getBean()返回对象，ApplicationContext类就是IoC容器。容器需要做的就是解析XML文件，通过反射构造对象。</p>
<blockquote>
<p>以上方法实际上没有实现DI依赖注入，需要自己主动获取，这种实现方式也被称作DL依赖查找。</p>
</blockquote>
<h5 id="scope"><a href="#scope" class="headerlink" title="scope"></a>scope</h5><p>Bean对象具有scope属性，常用的有两种：Singleton和Prototyp，默认是Singleton：</p>
<ul>
<li>Singleton，一个容器只创建一个Bean实例，每次getBean()都返回相同的实例；</li>
<li>Prototyp，每次getBean()都新创建一个Bean实例；</li>
<li>Session，每个HTTP Session创建一个Bean实例。</li>
</ul>
<blockquote>
<p>注意：Singleton强调一个容器只有一个Bean实例，不同容器可以有不同Bean实例。</p>
</blockquote>
<h5 id="import标签"><a href="#import标签" class="headerlink" title="import标签"></a>import标签</h5><p>如上所述，xml配置是非常好理解的。但是，我们需要把所有用到的bean对象都定义在xml文件中，而且还要定义bean对象之间复杂的依赖关系，xml文件将越来越庞大。实战中，会根据类型不同创建多个xml文件，并通过<code>&lt;import&gt;</code>标签引入。</p>
<p>例如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="读取配置文件"><a href="#读取配置文件" class="headerlink" title="读取配置文件"></a>读取配置文件</h5><p>类似配置数据源时，用户名和密码等信息我们一般不会直接写在xml文件里面，而是放在单独的properties文件中，使用<code>&lt;content:property-placeholder /&gt;</code> 标签可以读取配置文件。</p>
<p>例如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"classpath:db.properties"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"database"</span> <span class="attr">class</span>=<span class="string">"cn.lu.spring.ioc.placeholder.Database"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"$&#123;db.driver&#125;"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;db.url&#125;"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;db.username&#125;"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;db.password&#125;"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<code>${db.username}</code> 如果换成 <code>${username}</code> 将读取到本地用户。也就是说是由内置变量的，所以通常在properties文件中属性都要加前缀，避免冲突。</p>
</blockquote>
<h5 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h5><p>前面我们使用<code>&lt;property&gt;</code> 属性手工配置了Car对象和Wheel对象的依赖关系，此外，还可以使用<code>autowire</code> 属性自动装配。自动装配意味着IoC自动帮我找到Wheel对象，并赋值到Car对象的wheel属性。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"car"</span> <span class="attr">class</span>=<span class="string">"cn.lu.spring.ioc.Car"</span> <span class="attr">autowire</span>=<span class="string">"byType"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"wheel"</span> <span class="attr">class</span>=<span class="string">"cn.lu.spring.ioc.Wheel"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>autowire</code> 属性有三个值：</p>
<ul>
<li>no - 默认值，默认不自动装配；</li>
<li>byName - 通过Bean的id自动装配，这里我们把<code>id=&quot;wheel&quot;</code> 修改了<code>id=&quot;wheel2&quot;</code> 装配将会失败；</li>
<li>byType - 通过Bean的class自动装配，最常用。</li>
</ul>
<p>byType自动装配时，如果没有根据类型找到对象，或者找到多个对象，都会抛出异常。</p>
<h4 id="注解配置"><a href="#注解配置" class="headerlink" title="注解配置"></a>注解配置</h4><p>Spring 2.5以后出现了注解方式，使用注解意味着将集中的bean配置（xml文件）分散到各个bean对象中。个人觉得没有两种用法没有好坏之分。</p>
<h5 id="Component注解"><a href="#Component注解" class="headerlink" title="@Component注解"></a>@Component注解</h5><p>@Component注解起到XML文件中<code>&lt;bean/&gt;</code> 标签一样的作用，下面两种写法是等同的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span>(<span class="string">"car"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"car"</span> <span class="attr">class</span>=<span class="string">"Car"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>@Component注解的value属性等同于bean的id属性，@Component的value默认值为首字母小写的类名，一般可以省略。从@Component又衍生出@Controller、@Service和@Repository注解，本质是一样的。</p>
<h5 id="Autowired注解"><a href="#Autowired注解" class="headerlink" title="@Autowired注解"></a>@Autowired注解</h5><p>@Autowired/@Resource注解起到XML文件中<code>autowird</code> 属性的作用，@Autowired注解可以修饰类的成员变量，也可以修饰类的构造函数和成员方法。</p>
<p>@Autowired和@Resource的区别：</p>
<ul>
<li>@Autowired默认通过bean的类型注入，等价于<code>autowire=&quot;byType&quot;</code> ；</li>
<li>@Resource默认通过bean的名字注入，等价于<code>autowire=&quot;byName&quot;</code>。</li>
</ul>
<h5 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h5><p>引入自动装配和@Autowired注解后真正实现了依赖注入，当我们需要使用一个对象时，直接将其声明为@Autowired，容器负责帮我们构造这个对象的实例。@Autowired注解默认是按照类型构造的，也就是说容器负责查找实现类并通过反射进行构造，所以通常@Autowired注解修饰的是接口。</p>
<p>进一步思考一下，如果一个@Autowired注解修饰的接口有多个实现类，那么容器就不知道应该构造哪个类了，怎么办？这个时候我们可以增加@Qualifier注解来指定bean的名称。下面以UserService为例，有UserServiceMemoryImpl和UserServiceDatabaseImpl两个实现类，实现选择数据库实现，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier</span>(<span class="string">"userServiceDatabaseImpl"</span>)</span><br><span class="line">UserService userService;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>因为@Component默认bean名称为首字母小写的类名，所以可以使用userServiceDatabaseImpl，如果UserServiceDatabaseImpl在@Component中自定义了bean名称，那么要使用自定义的。</p>
</blockquote>
<h5 id="component-scan"><a href="#component-scan" class="headerlink" title="component-scan"></a>component-scan</h5><p>虽然加入@Component注解以后我们不需要在xml文件中定义<bean>了，但是我们还是需要告诉IoC容器去哪里扫描@Component注解，通过<code>&lt;context:component-scan&gt;</code> 标签实现。</bean></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"cn.lu.spring.ioc.bean"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>实际上在AutowiredAnnotationBeanPostProcessor中处理自动装配，但是要求开发者在xml文件中自己定义这个类的bean对象显然太low了，所以Spring为我们提供了<code>&lt;context:annotation-config&gt;</code> 标签来加载类似功能的类，由于<code>&lt;context:component-scan&gt;</code>包含了<code>&lt;context:annotation-config&gt;</code> 的功能，所以可以省略。</p>
<h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><p>Bean对象如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> Wheel wheel;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wheel</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：这里Car类不用实现setWheel()方法就可以注入wheel，这和反射的实现有关。</p>
</blockquote>
<p>使用如下：我们通过@Autowired注解直接注入Car对象，这才是真正的依赖注入。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class)</span><br><span class="line"><span class="meta">@ContextConfiguration</span>(locations = &#123;<span class="string">"spring-bean.xml"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IoCTest</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> Car car;</span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAnnotation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    logger.info(car.toString());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：这里我们没有显式创建ApplicationContext，是 @Runwith(SpringJUnit4ClassRunner.class)和@ContextConfiguration起了相同的作用。</p>
<h4 id="Java配置"><a href="#Java配置" class="headerlink" title="Java配置"></a>Java配置</h4><p>总结，到目前为止我们的用法是：</p>
<ul>
<li>在xml文件中定义component-scan，指向bean对象的包名；</li>
<li>在类中使用@Component和@Autowired注解。</li>
</ul>
<p>从Spring 3.0开始提供了Java Config也叫做Java配置，Spring Boot建议使用Java配置替代XML配置。</p>
<p>Java配置引入了@Configuration、@Bean、@ImportResource和@Value等注解。</p>
<h5 id="Configuration注解"><a href="#Configuration注解" class="headerlink" title="@Configuration注解"></a>@Configuration注解</h5><p>@Configuration注解就相当于一个xml文件，@Bean注解就相当于xml文件中的一个<code>&lt;bean/&gt;</code>  ，</p>
<p>例如：Java配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Config</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Wheel <span class="title">wheel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Wheel();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Car <span class="title">car</span><span class="params">(Wheel wheel)</span> </span>&#123;</span><br><span class="line">    Car car = <span class="keyword">new</span> Car();</span><br><span class="line">    car.setWheel(wheel);</span><br><span class="line">    <span class="keyword">return</span> car;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>等同于如下xml配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"wheel"</span> <span class="attr">class</span>=<span class="string">"cn.lu.spring.ioc.Wheel"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"car"</span> <span class="attr">class</span>=<span class="string">"cn.lu.spring.ioc.Car"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"wheel"</span> <span class="attr">ref</span>=<span class="string">"wheel"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="ComponentScan注解"><a href="#ComponentScan注解" class="headerlink" title="@ComponentScan注解"></a>@ComponentScan注解</h5><p>@ComponentScan注解相当于xml文件中的<code>&lt;context:component-scan /&gt;</code> 。</p>
<p>所以我们可以把xml文件替换为Java类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"cn.lu.spring.ioc.bean"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用时和前面基本一样，只需要把@ContextConfiguration配置的xml文件替换为class类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class)</span><br><span class="line"><span class="meta">@ContextConfiguration</span>(classes = &#123;JavaConfig.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IoCTestWithJavaConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h4><p>现在我们有三种方法定义一个Bean，选择哪一个呢？</p>
<p>XML配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"car"</span> <span class="attr">class</span>=<span class="string">"cn.lu.spring.ioc.Car"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>注解配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>Java配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaConfiguratoin</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Car <span class="title">car</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Car();</span><br><span class="line">  &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>习惯上，我们使用第二种方法@Component注解（实际更多使用@Controller、@Service等注解）来配置我们的业务Bean，XML不再使用，Java配置用来完成非业务Bean（例如：数据源）的配置。</p>
<blockquote>
<p>个人理解：@Component注解是侵入式的，XML和Java配置是不需要侵入源代码的，这是他们的优势。</p>
</blockquote>
<h3 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h3><p>下面看看在SpringBoot中如何使用IoC管理Bean对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceDemoApplication</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  UserService userService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子代码展示了最常见的用法：</p>
<ul>
<li>Spring容器扫描到@Service注解后创建UserServiceImpl类实例对象；</li>
<li>Spring容器扫描到@Controller注解后创建UserController类实例对象；</li>
<li>Spring容器扫描到@Autowired注解后将UserServiceImpl类实例对象注入到UserController类实例对象的userService属性中。</li>
</ul>
<p>上面过程很好理解，但仔细一想你会发现代码中没有出现@ComponentScan注解，Spring容器怎么知道去哪里扫描注解呢？还有，容器类ApplicationContext是如何创建的呢？</p>
<h4 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</h4><p>问题的答案就在@SpringBootApplication注解中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(excludeFilters = &#123;</span><br><span class="line">		<span class="meta">@Filter</span>(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span><br><span class="line">		<span class="meta">@Filter</span>(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootConfiguration &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@SpringBootApplication注解组合了@Configuration、@ComponentScan和@EnableAutoConfiguration三个最重要的注解，所以拥有了它们的功能。</p>
<p>我们知道一个@Configuration类文件对应一个XML配置文件，所以当Spring扫描到@Configuration注解后就会创建ApplicationContext容器类，并扫描@Component注解创建Bean对象放入容器类中。</p>
<p>@ComponentScan注解默认扫描当前包及其子目录下的源代码，所以Application类通常都是放在包的最外层，这样才可以保证web/service等目录下的注解可以被扫描到。</p>
<p>例如：新建应用在com.test.demo包下，引用的common项目在com.test.common包下，那么common项目中的@Component等注解是不生效的，因为Spring没有扫描它们。如果希望common包下的注解也生效，需要显式配置scanBasePackages，样例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span>(scanBasePackages = &#123;<span class="string">"com.test.demo"</span>, <span class="string">"com.test.common"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>@EnableAutoConfiguration是SpringBoot特性，和IoC无关，这里不展开。</p>
</blockquote>
<h4 id="ConfigurationProperties"><a href="#ConfigurationProperties" class="headerlink" title="@ConfigurationProperties"></a>@ConfigurationProperties</h4><p>@PropertySource注解起到和<code>&lt;context:property-placeholder&gt;</code> 标签一样的作用，读取proerties配置文件，并映射到Bean对象中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@PropertySource</span>(<span class="string">"classpath:db.properties"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DatabaseInfo</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Value</span>(<span class="string">"$&#123;db.driver&#125;"</span>)</span><br><span class="line">  <span class="keyword">private</span> String driver;</span><br><span class="line">  <span class="meta">@Value</span>(<span class="string">"$&#123;db.url&#125;"</span>)  </span><br><span class="line">  <span class="keyword">private</span> String url;</span><br><span class="line">  <span class="meta">@Value</span>(<span class="string">"$&#123;db.usernae&#125;"</span>)</span><br><span class="line">  <span class="keyword">private</span> String userame;</span><br><span class="line">  <span class="meta">@Value</span>(<span class="string">"$&#123;db.password&#125;"</span>)</span><br><span class="line">  <span class="keyword">private</span> String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@PropertySource注解和@Value注解配合使用，@Value可以设置默认值，例如：password默认值为<code>******</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Value</span>(<span class="string">"$&#123;db.password:******&#125;"</span>)</span><br><span class="line"><span class="keyword">private</span> String password;</span><br></pre></td></tr></table></figure>
<p>Spring Boot 提供了@ConfigurationProperties注解，读取配置文件更方便，可以不加@Value注解。prefix属性定义前缀名，连接符转换为驼峰，例如：<code>db.driver-class-name</code> 对应driverClassName。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"db"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceProperties</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String driver;</span><br><span class="line">  <span class="keyword">private</span> String url;</span><br><span class="line">  <span class="keyword">private</span> String username;</span><br><span class="line">  <span class="keyword">private</span> String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了生效还必须添加@EnableConfigurationProperties注解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(DataSourceProperties.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Config</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="扩展使用"><a href="#扩展使用" class="headerlink" title="扩展使用"></a>扩展使用</h3><p>前面介绍了IoC的最基本用法，帮助我们的应用程序创建类实例对象，下面看看其他用法。</p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>实际开发中，有时需要在Bean对象创建后和销毁前做一些操作，可以使用下面两个注解：</p>
<ul>
<li>@PostConstruct，在构造函数完成之后执行；</li>
<li>@PreDestroy，在析构函数执行之前执行；</li>
</ul>
<p>除了使用@PostConstruct注解，还可以实现InitializingBean接口和afterPropertiesSet()方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">UserController</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"UserController()"</span>);</span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="meta">@PostConstruct</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postConstruct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"UserController @PostConstruct"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@PreDestroy</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"UserController @PreDestroy"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"UserController afterPropertiesSet"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码的输出日志顺序为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">UserController()</span><br><span class="line">UserController @PostConstruct</span><br><span class="line">UserController afterPropertiesSet</span><br><span class="line">UserController @PreDestroy</span><br></pre></td></tr></table></figure>
<h4 id="Profile"><a href="#Profile" class="headerlink" title="@Profile"></a>@Profile</h4><p>@Profile注解为我们提供了在不同环境下创建不同Bean实例的能力。</p>
<p>一般用在配置类中，例如：生产环境MySQL和Redis需要使用集群配置，开发和测试环境使用单点配置就好了，这两种情况下的配置可能是不同的，这个时候@Profile就派上用场了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DatabaseConfig</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="meta">@Profile</span>(<span class="string">"dev"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> DataSource <span class="title">getDevDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DevDataSource();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="meta">@Profile</span>(<span class="string">"prod"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> DataSource <span class="title">getProdDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ProdDataSource();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DataSource是接口，DevDataSource和ProdDataSource是具体实现，根据运行环境的不同返回不同的实现。运行环境通过配置application.properties切换。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.profiles.active=dev</span><br></pre></td></tr></table></figure>
<h4 id="ImportResource"><a href="#ImportResource" class="headerlink" title="@ImportResource"></a>@ImportResource</h4><p>使用@ImportResource注解可以直接导入xml配置文件，这是从xml配置到java配置过渡的最简单方案。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ImportResource</span>(locations=&#123;<span class="string">"classpath:applicationContext.xml"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XmlConfiguration</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Import"><a href="#Import" class="headerlink" title="@Import"></a>@Import</h4><p>和@ImportResource注解类似，使用@Import注解可以导入其他配置类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ImportResource</span>(&#123;DatabaseConfig.class, RedisConfig.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfiguration</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="IoC容器"><a href="#IoC容器" class="headerlink" title="IoC容器"></a>IoC容器</h2><h3 id="JUnit"><a href="#JUnit" class="headerlink" title="JUnit"></a>JUnit</h3><p>我们的测试用例中使用ClassPathXmlApplicationContext做IoC容器，需要手工创建，并传入xml文件名。</p>
<h3 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h3><p>Spring和Tomcat集成后，使用的是WebApplicationContext，通过ContextLoaderListener创建。</p>
<p>ContextLoaderListener配置在webapp/WEB-INF/web.xml中：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>ContextLoaderListener是Tomcat的一个ServletContext，当它初始化的时候创建WebApplicationContext容器类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.web.context;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletContextListener;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextLoaderListener</span> <span class="keyword">extends</span> <span class="title">ContextLoader</span> <span class="keyword">implements</span> <span class="title">ServletContextListener</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Context初始化时创建IoC容器</span></span><br><span class="line">    <span class="keyword">this</span>.initWebApplicationContext(event.getServletContext());</span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextDestroyed</span><span class="params">(ServletContextEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.closeWebApplicationContext(event.getServletContext());</span><br><span class="line">    ContextCleanupListener.cleanupAttributes(event.getServletContext());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当Servelt容器启动时触发contextInitialized()方法，它执行基类ContextLoader的方法来构造容器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.web.context;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextLoader</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> WebApplicationContext context;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> WebApplicationContext <span class="title">initWebApplicationContext</span><span class="params">(ServletContext servletContext)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.context == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.context = <span class="keyword">this</span>.createWebApplicationContext(servletContext);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.context;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里可以看到最终调用createWebApplicationContext()方法返回WebApplicationContext类实例对象，这就是Tomcat中的IoC容器。后面的操作大家都了解了，WebApplicationContext容器负责管理Bean对象。</p>
<h3 id="SpringBoot-1"><a href="#SpringBoot-1" class="headerlink" title="SpringBoot"></a>SpringBoot</h3><p>我们再来看看目前流行的SpringBoot是如何创建Spring的IoC容器的。</p>
<p>SpringBoot其实更好理解一点，我们从程序入口开始看</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringbootApplication</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SpringApplication.run(SpringbootApplication.class, args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>入口是SpringApplication的run()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.boot;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringApplication</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">    ConfigurableApplicationContext context = <span class="keyword">null</span>;</span><br><span class="line">    context = <span class="keyword">this</span>.createApplicationContext();</span><br><span class="line">    <span class="keyword">this</span>.refreshContext(context);</span><br><span class="line">    <span class="keyword">return</span> context;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里只截取了和IoC相关代码，可以看到run()方法中创建了context容器，并调用refreshContext()方法加载Bean对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.boot;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringApplication</span> </span>&#123;   </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> webEnvironment;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> ConfigurableApplicationContext <span class="title">createApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; contextClass = <span class="keyword">this</span>.applicationContextClass;</span><br><span class="line">    <span class="keyword">if</span>(contextClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.webEnvironment) &#123;</span><br><span class="line">        contextClass = Class.forName(<span class="string">"AnnotationConfigEmbeddedWebApplicationContext"</span>); </span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        contextClass = Class.forName(<span class="string">"AnnotationConfigApplicationContext"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (ConfigurableApplicationContext)BeanUtils.instantiate(contextClass);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>类名太长，这里省略了包名。</p>
</blockquote>
<p>由于我们大部分是web应用，所以使用的是AnnotationConfigEmbeddedWebApplicationContext，从名字上可以看出，这个ApplicationContext（容器）是基于注解创建的，支持嵌入式web应用。</p>
<p><a href="https://www.jianshu.com/p/1417eefd2ab1" target="_blank" rel="noopener">Spring探秘|妙用BeanPostProcessor</a></p>
<p><a href="https://blog.csdn.net/soonfly/article/details/69480058" target="_blank" rel="noopener">bean作用域：理解Bean生命周期</a></p>
</div><div class="tags"><a href="/tags/Spring/">Spring</a><a href="/tags/IoC/">IoC</a></div><div class="post-nav"><a class="pre" href="/2018/05/27/spring-aop/">Spring-AOP</a><a class="next" href="/2018/05/21/knowledge-thread/">【置顶】Java多线程一篇就够</a></div><div id="vcomment"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script><script>var notify = 'false' == true ? true : false;
var verify = 'false' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'5mrT8f80zgJVcJvIPrSGzFjV-gzGzoHsz',
  appKey:'Db9rWWROewfegKQJkbYncKt1',
  placeholder:'请在这里留下你要说的话',
  avatar:'mm',
  guest_info:guest_info,
  pageSize:'10'
})</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JAVA/">JAVA</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/WEB/">WEB</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/分布式/">分布式</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/工具/">工具</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/并发编程/">并发编程</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/消息队列/">消息队列</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/">设计模式</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/索引/" style="font-size: 15px;">索引</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/mq/" style="font-size: 15px;">mq</a> <a href="/tags/rocketmq/" style="font-size: 15px;">rocketmq</a> <a href="/tags/并发/" style="font-size: 15px;">并发</a> <a href="/tags/线程/" style="font-size: 15px;">线程</a> <a href="/tags/线程池/" style="font-size: 15px;">线程池</a> <a href="/tags/任务调度/" style="font-size: 15px;">任务调度</a> <a href="/tags/多线程/" style="font-size: 15px;">多线程</a> <a href="/tags/排队策略/" style="font-size: 15px;">排队策略</a> <a href="/tags/饱和策略/" style="font-size: 15px;">饱和策略</a> <a href="/tags/synchronized/" style="font-size: 15px;">synchronized</a> <a href="/tags/wait/" style="font-size: 15px;">wait</a> <a href="/tags/notify/" style="font-size: 15px;">notify</a> <a href="/tags/内存模型/" style="font-size: 15px;">内存模型</a> <a href="/tags/内存可见性/" style="font-size: 15px;">内存可见性</a> <a href="/tags/指令重排序/" style="font-size: 15px;">指令重排序</a> <a href="/tags/Database/" style="font-size: 15px;">Database</a> <a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/Sharding/" style="font-size: 15px;">Sharding</a> <a href="/tags/单例/" style="font-size: 15px;">单例</a> <a href="/tags/线程安全/" style="font-size: 15px;">线程安全</a> <a href="/tags/分布式/" style="font-size: 15px;">分布式</a> <a href="/tags/SnowFlake/" style="font-size: 15px;">SnowFlake</a> <a href="/tags/github/" style="font-size: 15px;">github</a> <a href="/tags/WEB/" style="font-size: 15px;">WEB</a> <a href="/tags/短地址/" style="font-size: 15px;">短地址</a> <a href="/tags/哈希/" style="font-size: 15px;">哈希</a> <a href="/tags/hashCode/" style="font-size: 15px;">hashCode</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/Hashmap/" style="font-size: 15px;">Hashmap</a> <a href="/tags/哈希冲突/" style="font-size: 15px;">哈希冲突</a> <a href="/tags/mybatis/" style="font-size: 15px;">mybatis</a> <a href="/tags/ConcurrentHashMap/" style="font-size: 15px;">ConcurrentHashMap</a> <a href="/tags/SpringBoot/" style="font-size: 15px;">SpringBoot</a> <a href="/tags/热部署/" style="font-size: 15px;">热部署</a> <a href="/tags/Reentrantlock/" style="font-size: 15px;">Reentrantlock</a> <a href="/tags/Spring/" style="font-size: 15px;">Spring</a> <a href="/tags/IoC/" style="font-size: 15px;">IoC</a> <a href="/tags/springboot/" style="font-size: 15px;">springboot</a> <a href="/tags/AOP/" style="font-size: 15px;">AOP</a> <a href="/tags/注解/" style="font-size: 15px;">注解</a> <a href="/tags/动态代理/" style="font-size: 15px;">动态代理</a> <a href="/tags/反射/" style="font-size: 15px;">反射</a> <a href="/tags/泛型/" style="font-size: 15px;">泛型</a> <a href="/tags/Mybatis/" style="font-size: 15px;">Mybatis</a> <a href="/tags/Spring-Cloud/" style="font-size: 15px;">Spring Cloud</a> <a href="/tags/Eureka/" style="font-size: 15px;">Eureka</a> <a href="/tags/服务治理/" style="font-size: 15px;">服务治理</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/06/06/springcloud-eureka/">Spring Cloud - Eureka</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/05/spring-ioc-inside/">Spring-IoC原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/spring-ioc-advanced/">Spring-IoC进阶</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/31/mybatis-aop/">Mybatis动态代理原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/29/java-basic-generic/">Java基础-泛型</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/28/java-basic-proxy/">Java基础-动态代理</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/28/java-basic-annotation/">Java基础-注解</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/28/java-basic-reflect/">Java基础-反射</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/27/spring-aop/">Spring-AOP</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/22/spring-ioc/">Spring-IoC</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://github.com/waterlu" title="waterlu's github" target="_blank">waterlu's github</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">Waterlu's Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>