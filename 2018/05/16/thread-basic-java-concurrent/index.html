<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="个人技术博客"><title>Java并行包 | Waterlu's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Java并行包</h1><a id="logo" href="/.">Waterlu's Blog</a><p class="description">以铜为鉴，可正衣冠；以史为鉴，可知兴替；以人为鉴，可明得失。</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Java并行包</h1><div class="post-meta">May 16, 2018<span> | </span><span class="category"><a href="/categories/并发编程/">并发编程</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><a class="disqus-comment-count" href="/2018/05/16/thread-basic-java-concurrent/#vcomment"><span class="valine-comment-count" data-xid="/2018/05/16/thread-basic-java-concurrent/"></span><span> 条评论</span></a><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#并行包使用"><span class="toc-number">1.</span> <span class="toc-text">并行包使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ConcurrentHashMap"><span class="toc-number">1.1.</span> <span class="toc-text">ConcurrentHashMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BlockingQueue"><span class="toc-number">1.2.</span> <span class="toc-text">BlockingQueue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CountDownLatch"><span class="toc-number">1.3.</span> <span class="toc-text">CountDownLatch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CyclicBarrier"><span class="toc-number">1.4.</span> <span class="toc-text">CyclicBarrier</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Semaphore"><span class="toc-number">1.5.</span> <span class="toc-text">Semaphore</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadPoolExecutor"><span class="toc-number">1.6.</span> <span class="toc-text">ThreadPoolExecutor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AtomicInteger"><span class="toc-number">1.7.</span> <span class="toc-text">AtomicInteger</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReentrantLock"><span class="toc-number">1.8.</span> <span class="toc-text">ReentrantLock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReadWriteLock"><span class="toc-number">1.9.</span> <span class="toc-text">ReadWriteLock</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-number">2.</span> <span class="toc-text">参考</span></a></li></ol></div></div><div class="post-content"><h2 id="并行包使用"><a href="#并行包使用" class="headerlink" title="并行包使用"></a>并行包使用</h2><p>Java从1.5开始提供了并发工具包java.util.concurrent，极大简化了多线程编程的难度。源码来自大神Doug Lea的个人贡献，如果你在JDK1.4.2下做过多线程网络编程，你就知道这有多重要。</p>
<p>并发包中提供了高性能且线程安全的集合类以及并发场景中常用的并发锁和原子操作类。本文仅介绍如何使用并发包中的类，对于其底层原理和实现，将另开章节进行讨论。</p>
<p>具体介绍每一个类之前，先做一个横向对比，可以更容易理解并行包引入这些类的目的。</p>
<table>
<thead>
<tr>
<th>基础类或方法</th>
<th>并行包类</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>HashMap</td>
<td>ConcurrentHashMap</td>
<td>Map</td>
</tr>
<tr>
<td>wait()/notify()</td>
<td>BlockingQueue</td>
<td>线程通信</td>
</tr>
<tr>
<td>join()</td>
<td>CountDownLatch</td>
<td>一个线程等待其他线程</td>
</tr>
<tr>
<td></td>
<td>CyclicBarrier</td>
<td>多个线程互相等待，到一个点后共同执行</td>
</tr>
<tr>
<td>synchronized</td>
<td>Semaphore</td>
<td>控制多线程并发数量</td>
</tr>
<tr>
<td>synchronized</td>
<td>ReentrantLock</td>
<td>并发锁</td>
</tr>
<tr>
<td>Integer</td>
<td>AtomicInteger</td>
<td>原子操作类</td>
</tr>
</tbody>
</table>
<h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p>先做一个对比</p>
<table>
<thead>
<tr>
<th>Map类</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>HashMap</td>
<td>线程不安全，多线程扩容可能出现循环链表导致get()方法空转（JDK1.8以前）</td>
</tr>
<tr>
<td>HashTable</td>
<td>线程安全，用synchronized锁定读写方法，锁住整个Map，效率低</td>
</tr>
<tr>
<td>ConcurrentHashMap</td>
<td>线程安全，使用Segment减小锁的颗粒度，效率高</td>
</tr>
</tbody>
</table>
<p>使用方法和HashMap一样，只需要把<code>new HashMap()</code> 改成<code>new ConcurrentHashMap()</code> 即可。</p>
<h3 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h3><p>顾名思义，这是一个阻塞队列。使用BlockingQueue可以方便的实现线程之间的通信，典型的就是生产者-消费者模式。BlockingQueue一般都是FIFO先进先出的，和排队一样。从下图中可以看出，这就是producer和consumer，换句话说，之前我们通过wait()/notify()自己实现了生产者和消费者，直接使用BlockingQueue也可以达到同样的效果，而且更简单。</p>
<p><img src="/images/thread-java-concurrent-blockingqueue.png" alt=""></p>
<p>下面看看如何使用BlockingQueue实现生产者-消费者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockingQueueExample</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(BlockingQueueExample.class);</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 有界阻塞队列</span></span><br><span class="line">    BlockingQueue queue = <span class="keyword">new</span> ArrayBlockingQueue(<span class="number">5</span>);</span><br><span class="line">    <span class="comment">// 无界阻塞队列</span></span><br><span class="line">    <span class="comment">// BlockingQueue queue = new LinkedBlockingQueue();</span></span><br><span class="line">    <span class="comment">// 0阻塞队列</span></span><br><span class="line">    <span class="comment">// BlockingQueue queue = new SynchronousQueue();</span></span><br><span class="line">    Producer producer = <span class="keyword">new</span> Producer(queue);</span><br><span class="line">    Consumer consumer = <span class="keyword">new</span> Consumer(queue);</span><br><span class="line">    <span class="keyword">new</span> Thread(producer).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(consumer).start();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> BlockingQueue queue = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(BlockingQueue queue)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">while</span> (count &lt; <span class="number">20</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          count++;</span><br><span class="line">          queue.put(<span class="keyword">new</span> Integer(count));</span><br><span class="line">          logger.info(<span class="string">"put "</span> + count);</span><br><span class="line">          Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> BlockingQueue queue = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(BlockingQueue queue)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          logger.info(<span class="string">"get "</span> + queue.take());</span><br><span class="line">          Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>首先，创建一个线程共享的BlockingQueue对象，</li>
<li>然后，生产者调用put()方法往队列里放数据，消费者调用take()方法从队列中取数据；</li>
<li>数据按照FIFO的规则先进先出，put()方法新增数据到队列末尾，take()方法从队列头读取并移除数据；</li>
<li>put()方法和take()方法都可以阻塞：如果队列满了，put()方法阻塞；如果队列空了，take()方法阻塞。</li>
</ul>
<p>BlockingQueue是一个接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util.concurrent;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// Inserts the specified element into this queue, waiting up </span></span><br><span class="line">  <span class="comment">// to the specified wait time if necessary for space to become available.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">  <span class="comment">// Retrieves and removes the head of this queue, waiting if necessary</span></span><br><span class="line">  <span class="comment">// until an element becomes available.</span></span><br><span class="line">  <span class="function">E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>ArrayBlockingQueue</strong></p>
<p>使用数组实现阻塞队列，队列大小有上限。</p>
<p><strong>LinkedBlockingQueue</strong></p>
<p>使用链表实现阻塞队列，每个元素通过next指针链接到下一个元素；队列默认最大Integer.MAX_VALUE，也可以自定义；</p>
<p><strong>SynchronousQueue</strong></p>
<p>队列中最多只能有一个元素，效果和ArrayBlockingQueue(1)是一样的。</p>
<blockquote>
<p>看上去很眼熟吧，这就是ThreadPoolExecutor的三种排队策略：有界队列、无界队列和0队列。</p>
</blockquote>
<h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><p><code>latch[lætʃ]</code> 是门闩的意思，CountDownLatch就是倒数的门闩。我的理解就是：有N个门锁，一个一个打开，都打开就可以离开了。中文翻译我觉得应该是<code>倒计数锁</code> 。</p>
<p>下面看一个例子：初始化counter计数为2，每次调用<code>counter.countDown();</code> 计数器减1，<code>counter.await();</code> 方法阻塞到计数器为0时返回，起到和join()方法一样的效果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchExample</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    CountDownLatch counter = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line">    Task task1 = <span class="keyword">new</span> Task(<span class="number">1000</span>, counter);</span><br><span class="line">    Task task2 = <span class="keyword">new</span> Task(<span class="number">2000</span>, counter);</span><br><span class="line">    task1.start();</span><br><span class="line">    task2.start();</span><br><span class="line">    <span class="comment">// task1.join();</span></span><br><span class="line">    <span class="comment">// task2.join();</span></span><br><span class="line">    counter.await();</span><br><span class="line">    System.out.print(<span class="string">"done"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> time = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> CountDownLatch counter;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(<span class="keyword">int</span> time, CountDownLatch counter)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.time = time;</span><br><span class="line">      <span class="keyword">this</span>.counter = counter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(time);</span><br><span class="line">        <span class="keyword">this</span>.counter.countDown();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CountDownLatch与join()的联系和区别：</p>
<ul>
<li>CountDownLatch和join()都可以实现主线程等待子线程完成后再继续的效果，例如：我们的测试例子中很多时候main()方法都需要启动子线程，通过CountDownLatch和join()可以准确等到子线程执行完成后输出测试信息，否则我们只能在主线程中Thread.sleep()，看上去就很弱，另外sleep多长时间很不好确定；</li>
<li>调用thread.join()方法必须等thread线程执行完成才返回，而CountDownLatch只要检测到计数器为0就可以返回（thread线程可以在执行过程中进行countDown()操作），所以CountDownLatch通过计数器提供了更灵活的控制机制；</li>
<li>我们通常使用线程池启动子线程，子线程只需要实现runnable接口，这种情况下Thread类对象是封装在线程池里面的，我们不方便拿到，也就不方便调用它的join()方法；使用CountDownLatch就简单多了，只需要在run()方法退出前调用countDown()方法即可；</li>
<li>综上，实战中CountDownLatch的应用场景比join()多。</li>
</ul>
<h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><p>循环栅栏，和CountDownLatch有点像。CountDownLatch是一个线程等待其他线程的任务全部完成或者部分完成，然后才能继续进行。例如：厨艺比赛，大厨有几个助手分别做主菜、配菜、甜点，都好了，大厨宣布完成。CyclicBarrier也是线程等待，但不是一个线程等待其他线程，而是多个线程之间互相等待，都等到一个时间点以后再继续进行。例如：集体旅游，所有人都到达第一个景点以后，再出发去第二个景点。</p>
<p>还是看代码更容易理解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierExample</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>, <span class="keyword">new</span> MainTask());</span><br><span class="line">    Task task1 = <span class="keyword">new</span> Task(<span class="number">1000</span>, barrier);</span><br><span class="line">    Task task2 = <span class="keyword">new</span> Task(<span class="number">2000</span>, barrier);</span><br><span class="line">    task1.start();</span><br><span class="line">    task2.start();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MainTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"MainTask run()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> time = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> CyclicBarrier barrier;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(<span class="keyword">int</span> time, CyclicBarrier barrier)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.time = time;</span><br><span class="line">      <span class="keyword">this</span>.barrier = barrier;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(time);</span><br><span class="line">        <span class="keyword">this</span>.barrier.await();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>首先，CyclicBarrier可以指定一个barrierAction，当所有线程都到达barrier后执行；</li>
<li>也可以不指定barrierAction，那么CyclicBarrier看上去就和CountDownLatch很像了。</li>
</ul>
<p>CyclicBarrier和CountDownLatch的区别：</p>
<ul>
<li>CyclicBarrier是子线程之间的互相等待，在子线程内调用<code>barrier.await();</code> 相当于这个子线程已经到达栅栏点，等到所有子线程全部到达栅栏点时，所有这些子线程全部同时被唤醒，继续执行；</li>
<li>CountDownLatch是主线程等待子线程，各个子线程之间没有关系；</li>
<li>CyclicBarrier如果设置了barrierAction，相当于可以触发主线程继续操作。</li>
</ul>
<h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><p>信号量这个词用的比较多，Java中的含义是控制并发线程数量。我们知道synchronized同步代码块有加锁和释放锁的机制，可以认为synchronized只有1把锁，而Semaphore是N把锁。</p>
<p>Semaphore最多可以被锁N次，以后再试图加锁就会失败，必须等前面的线程释放锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(SemaphoreExample.class);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">30</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            threadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        logger.info(<span class="string">"run"</span>);</span><br><span class="line">                        semaphore.acquire();</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                        semaphore.release();</span><br><span class="line">                        logger.info(<span class="string">"done"</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>调用acquire()方法获得锁，计数加1；</li>
<li>调用release()方法释放锁，计数减1；</li>
<li>没有空闲锁的时候acquire()方阻塞等待；</li>
</ul>
<h3 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h3><p>单独有说明，这里不再重复。</p>
<h3 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h3><p>保证读写是原子操作的Integer。<code>i++</code> 不是原子操作，实际是三步：第一步从内存读取数据到寄存器，第二步寄存器数值加1，第三步回写寄存器数值到内存。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util.concurrent.atomic;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicInteger</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 增加并返回增加后的值</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">addAndGet</span><span class="params">(<span class="keyword">int</span> delta)</span> </span>&#123;&#125;</span><br><span class="line">  <span class="comment">// 增加并返回增加前的值</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAdd</span><span class="params">(<span class="keyword">int</span> delta)</span> </span>&#123;&#125;</span><br><span class="line">  <span class="comment">// 等同于addAndGet(1)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="comment">// 等同于getAndAdd(1)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;&#125;  </span><br><span class="line">  <span class="comment">// 如果当前值等于expect，将其更新为update，并返回true；否则返回false</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么用AtomicInteger替换Integer？还是线程安全问题。</p>
<p>下面的代码，启动100个任务，每个任务自增100次，正确的计算结果应该是10000。但是，如果我们像这么这样写代码，最后输出的sum结果很可能不是10000。原因就在于sum++操作不是线程安全的。</p>
<blockquote>
<p>例如：当前主内存中sum的值是100，两个线程同时把100读取到自己的工作内存中，实现+1操作，最后两个线程都回写101到主内存，实际上我的期望值是102。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerExample</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Task task = <span class="keyword">new</span> Task();</span><br><span class="line">    ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;</span><br><span class="line">      executorService.execute(task);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"sum="</span> + sum);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">100</span>; i++) &#123;</span><br><span class="line">        sum ++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用synchronized可以实现线程安全，但是基于悲观锁的思路，效率太低。可以将int替换为AtomicInteger，既实现线程安全，又保证了效率（基于CAS的乐观锁）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerExample</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger integer = <span class="keyword">new</span> AtomicInteger();	<span class="comment">// 改动</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">100</span>; i++) &#123;</span><br><span class="line">        integer.incrementAndGet();	<span class="comment">// 改动</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：这里使用volatile是不能保证线程安全的，因为++操作线程不安全。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>虽然给sum增加了volatile关键字，但是最后的计算结果也可能不是10000。volatile关键字保证可见性和不重排序，就是每次读数据时，从主内存同步到工作内存，每次回写数据时，立即同步到工作内存。但++操作是在CPU寄存器内的操作，不会立即同步到工作内存，当然也不会立即同步到主内存。</p>
<blockquote>
<p>对于任意单个volatile变量的读写具有原子性，但类似于<code>volatile++</code>这种复合操作不具有原子性。</p>
</blockquote>
<h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p>并发包提供了重入锁，用来代替synchronized</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockExample</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(LockExample.class);</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    Task task1 = <span class="keyword">new</span> Task(<span class="number">1000</span>, lock);</span><br><span class="line">    Task task2 = <span class="keyword">new</span> Task(<span class="number">2000</span>, lock);</span><br><span class="line">    task1.start();</span><br><span class="line">    task2.start();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> time = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Lock lock;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(<span class="keyword">int</span> time, Lock lock)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.time = time;</span><br><span class="line">      <span class="keyword">this</span>.lock = lock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        logger.info(<span class="string">"run"</span>);</span><br><span class="line">        lock.lock();</span><br><span class="line">        Thread.sleep(time);</span><br><span class="line">        logger.info(<span class="string">"done"</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下两种代码是等价的，都可以起到同步锁的作用</p>
<p>使用synchronized</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (Task.class) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Thread.sleep(time);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用ReentrantLock</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  lock.lock();</span><br><span class="line">  Thread.sleep(time);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：请在finally里释放锁。</p>
<p><strong>ReentrantLock能替换synchronized吗</strong></p>
<p>道理上讲，肯定是可以的，实战中根据实际情况选择，没有必要教条的一定要用ReentrantLock。首先，ReentrantLock能实现synchronized的全部功能，而且还提供了更多方法，功能更强大，某些情况下效率也更高。不多，synchronized就一无是处吗？synchronized的好处是简单，在实战中简单就意味着bug少。试想，如果使用ReentrantLock忘记调用<code>lock.unlock();</code> 或者某些异常情况下<code>lock.unlock();</code> 没有执行怎么办。功能强大的副作用就是复杂，容易出错。</p>
<p>下面再来看看ReentrantLock增加的功能</p>
<p>并行包中的Lock接口提供了tryLock()功能，注意lock()和unlock()方法都是没有返回值的，lock()如果得不到锁会一直阻塞。tryLock()方法试图立即锁定Lock实例，如果锁定成功 true，如果Lock实例已被锁定返回 false。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util.concurrent.locks;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">// 如果加锁成功立即返回true</span></span><br><span class="line">  <span class="comment">// 等待time时间得不到锁返回false</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>tryLock()方法可以避免某个线程由于线程饥饿得不到锁，一直阻塞在lock()，为我们提供了错误处理的机会。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> time = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> Lock lock;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(<span class="keyword">int</span> time, Lock lock)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.time = time;</span><br><span class="line">    <span class="keyword">this</span>.lock = lock;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> getLock = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      logger.info(<span class="string">"run"</span>);</span><br><span class="line">      <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span>(!getLock) &#123;</span><br><span class="line">        getLock = lock.tryLock(<span class="number">100</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">5</span>) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!getLock) &#123;</span><br><span class="line">        logger.error(<span class="string">"lock failed"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      Thread.sleep(time);</span><br><span class="line">      logger.info(<span class="string">"done"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (getLock) &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面为使用tryLock()方法的代码，比使用lock()要复杂一些，但是更加实战。尤其在分布式环境中，抢不到锁时返回错误比阻塞在那里等HTTP调用超时要好得多。</p>
<h3 id="ReadWriteLock"><a href="#ReadWriteLock" class="headerlink" title="ReadWriteLock"></a>ReadWriteLock</h3><p>读写锁就是两个锁，一个读锁，一个写锁，适合读多写少的情况。读锁可以加锁多次，写锁智能加锁一次。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">lock.readLock().lock();</span><br><span class="line">lock.readLock().unlock();</span><br><span class="line">lock.writeLock().lock();</span><br><span class="line">lock.writeLock().unlock();</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.importnew.com/26461.html" target="_blank" rel="noopener">并发编程 – Concurrent 用户指南</a></p>
<p><a href="http://www.importnew.com/27811.html" target="_blank" rel="noopener">面试必问的 CAS ，要多了解</a></p>
</div><div class="tags"><a href="/tags/ConcurrentHashMap/">ConcurrentHashMap</a></div><div class="post-nav"><a class="pre" href="/2018/05/17/thread-java-concurrent-sourcecode/">并行包源码分析</a><a class="next" href="/2018/05/15/rocketmq-starter/">SpringBoot整合RocketMQ</a></div><div id="vcomment"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script><script>var notify = 'false' == true ? true : false;
var verify = 'false' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'5mrT8f80zgJVcJvIPrSGzFjV-gzGzoHsz',
  appKey:'Db9rWWROewfegKQJkbYncKt1',
  placeholder:'请在这里留下你要说的话',
  avatar:'mm',
  guest_info:guest_info,
  pageSize:'10'
})</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JAVA/">JAVA</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/WEB/">WEB</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/分布式/">分布式</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/工具/">工具</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/并发编程/">并发编程</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/消息队列/">消息队列</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/">设计模式</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/索引/" style="font-size: 15px;">索引</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/mq/" style="font-size: 15px;">mq</a> <a href="/tags/rocketmq/" style="font-size: 15px;">rocketmq</a> <a href="/tags/并发/" style="font-size: 15px;">并发</a> <a href="/tags/线程/" style="font-size: 15px;">线程</a> <a href="/tags/线程池/" style="font-size: 15px;">线程池</a> <a href="/tags/任务调度/" style="font-size: 15px;">任务调度</a> <a href="/tags/多线程/" style="font-size: 15px;">多线程</a> <a href="/tags/排队策略/" style="font-size: 15px;">排队策略</a> <a href="/tags/饱和策略/" style="font-size: 15px;">饱和策略</a> <a href="/tags/synchronized/" style="font-size: 15px;">synchronized</a> <a href="/tags/wait/" style="font-size: 15px;">wait</a> <a href="/tags/notify/" style="font-size: 15px;">notify</a> <a href="/tags/内存模型/" style="font-size: 15px;">内存模型</a> <a href="/tags/内存可见性/" style="font-size: 15px;">内存可见性</a> <a href="/tags/指令重排序/" style="font-size: 15px;">指令重排序</a> <a href="/tags/Database/" style="font-size: 15px;">Database</a> <a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/Sharding/" style="font-size: 15px;">Sharding</a> <a href="/tags/单例/" style="font-size: 15px;">单例</a> <a href="/tags/线程安全/" style="font-size: 15px;">线程安全</a> <a href="/tags/分布式/" style="font-size: 15px;">分布式</a> <a href="/tags/SnowFlake/" style="font-size: 15px;">SnowFlake</a> <a href="/tags/github/" style="font-size: 15px;">github</a> <a href="/tags/WEB/" style="font-size: 15px;">WEB</a> <a href="/tags/短地址/" style="font-size: 15px;">短地址</a> <a href="/tags/哈希/" style="font-size: 15px;">哈希</a> <a href="/tags/hashCode/" style="font-size: 15px;">hashCode</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/Hashmap/" style="font-size: 15px;">Hashmap</a> <a href="/tags/哈希冲突/" style="font-size: 15px;">哈希冲突</a> <a href="/tags/mybatis/" style="font-size: 15px;">mybatis</a> <a href="/tags/ConcurrentHashMap/" style="font-size: 15px;">ConcurrentHashMap</a> <a href="/tags/SpringBoot/" style="font-size: 15px;">SpringBoot</a> <a href="/tags/热部署/" style="font-size: 15px;">热部署</a> <a href="/tags/Reentrantlock/" style="font-size: 15px;">Reentrantlock</a> <a href="/tags/Spring/" style="font-size: 15px;">Spring</a> <a href="/tags/IoC/" style="font-size: 15px;">IoC</a> <a href="/tags/springboot/" style="font-size: 15px;">springboot</a> <a href="/tags/AOP/" style="font-size: 15px;">AOP</a> <a href="/tags/注解/" style="font-size: 15px;">注解</a> <a href="/tags/动态代理/" style="font-size: 15px;">动态代理</a> <a href="/tags/反射/" style="font-size: 15px;">反射</a> <a href="/tags/泛型/" style="font-size: 15px;">泛型</a> <a href="/tags/Mybatis/" style="font-size: 15px;">Mybatis</a> <a href="/tags/Spring-Cloud/" style="font-size: 15px;">Spring Cloud</a> <a href="/tags/Eureka/" style="font-size: 15px;">Eureka</a> <a href="/tags/服务治理/" style="font-size: 15px;">服务治理</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/06/06/springcloud-eureka/">Spring Cloud - Eureka</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/05/spring-ioc-inside/">Spring-IoC原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/spring-ioc-advanced/">Spring-IoC进阶</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/31/mybatis-aop/">Mybatis动态代理原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/29/java-basic-generic/">Java基础-泛型</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/28/java-basic-proxy/">Java基础-动态代理</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/28/java-basic-annotation/">Java基础-注解</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/28/java-basic-reflect/">Java基础-反射</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/27/spring-aop/">Spring-AOP</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/22/spring-ioc/">Spring-IoC</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://github.com/waterlu" title="waterlu's github" target="_blank">waterlu's github</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">Waterlu's Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>