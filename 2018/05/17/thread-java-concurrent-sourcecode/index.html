<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="个人技术博客"><title>并行包源码分析 | Waterlu's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">并行包源码分析</h1><a id="logo" href="/.">Waterlu's Blog</a><p class="description">以铜为鉴，可正衣冠；以史为鉴，可知兴替；以人为鉴，可明得失。</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">并行包源码分析</h1><div class="post-meta">May 17, 2018<span> | </span><span class="category"><a href="/categories/并发编程/">并发编程</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><a class="disqus-comment-count" href="/2018/05/17/thread-java-concurrent-sourcecode/#vcomment"><span class="valine-comment-count" data-xid="/2018/05/17/thread-java-concurrent-sourcecode/"></span><span> 条评论</span></a><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#基础理论"><span class="toc-number">1.</span> <span class="toc-text">基础理论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CAS"><span class="toc-number">1.1.</span> <span class="toc-text">CAS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Unsafe类"><span class="toc-number">1.1.1.</span> <span class="toc-text">Unsafe类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ABA问题"><span class="toc-number">1.1.2.</span> <span class="toc-text">ABA问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AQS"><span class="toc-number">1.2.</span> <span class="toc-text">AQS</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#源码解析"><span class="toc-number">2.</span> <span class="toc-text">源码解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AtomicInteger"><span class="toc-number">2.1.</span> <span class="toc-text">AtomicInteger</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AbstractQueuedSynchronizer"><span class="toc-number">2.2.</span> <span class="toc-text">AbstractQueuedSynchronizer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReentrantLock"><span class="toc-number">2.3.</span> <span class="toc-text">ReentrantLock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NonfairSync"><span class="toc-number">2.4.</span> <span class="toc-text">NonfairSync</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AQS-1"><span class="toc-number">2.5.</span> <span class="toc-text">AQS</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#原理分析"><span class="toc-number">3.</span> <span class="toc-text">原理分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-number">4.</span> <span class="toc-text">参考</span></a></li></ol></div></div><div class="post-content"><h2 id="基础理论"><a href="#基础理论" class="headerlink" title="基础理论"></a>基础理论</h2><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p>CAS是英文Compare And Swap的简称，从字母也能够理解其含义：比较并替换。回想一下数据库中经常使用的乐观锁就是CAS的思想。CAS同时也是Java并行包的基础，可以简单认为syschronized是悲观锁，基于CAS的Java并行包是乐观锁。</p>
<p>CAS对应Unsafe类中的compareAndSwap方法，这个方法实际上需要三个参数：(1)数据的内存地址、(2)预期当前值和(3)即将更新值；执行compareAndSwap方法时会判断当前内存值，如果等于预期当前值，那么替换为新值并返回成功；如果不等于预期当期值，那么不做更新操作，返回失败。</p>
<blockquote>
<p> 这里的comapre和swap是一组原子操作，不会被打断。</p>
</blockquote>
<p>我们知道，syschronized可以实现原子性，为避免多个线程同时修改一个数据引发问题，我们在每个线程修改数据前加锁，保证同时只有一个线程操作数据，这样肯定是线程安全的，但是效率低。因为，大多数情况下不存在多个线程同时修改数据的情况，所以大多数情况下加锁和解锁操作是废操作。CAS的思路默认没有线程同时执行，如果出现线程并发修改情况，只有一个线程可以compareAndSwap成功，其他线程出错后重试。</p>
<blockquote>
<p>凡事没有绝对，如果真的存在多个线程频繁修改同一个数据的业务场景，那么syschronized效率是高于CAS的，因为一旦CAS需要频繁重试，效率自然下降。</p>
</blockquote>
<h4 id="Unsafe类"><a href="#Unsafe类" class="headerlink" title="Unsafe类"></a>Unsafe类</h4><p>CAS的核心实现是Unsafe类，Unsafe类功能强大，使Java拥有了像C一样直接访问内存空间的能力，所以是非常危险的，慎用。Unsafe类的核心方法都是native的，下面看看代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> sun.misc;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Unsafe</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe theUnsafe;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title">getUnsafe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> theUnsafe;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    theUnsafe = <span class="keyword">new</span> Unsafe();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Unsafe</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapObject</span><span class="params">(Object obj, <span class="keyword">long</span> offset, </span></span></span><br><span class="line"><span class="function"><span class="params">                                                   Object expect, Object update)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object obj, <span class="keyword">long</span> offset, </span></span></span><br><span class="line"><span class="function"><span class="params">                                                <span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapLong</span><span class="params">(Object obj, <span class="keyword">long</span> offset, </span></span></span><br><span class="line"><span class="function"><span class="params">                                                 <span class="keyword">long</span> expect, <span class="keyword">long</span> update)</span></span>; </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object obj, <span class="keyword">long</span> offset, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> expect;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      expect = <span class="keyword">this</span>.getIntVolatile(obj, offset);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(obj, offset, expect, expect + update));</span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">getIntVolatile</span><span class="params">(Object var1, <span class="keyword">long</span> var2)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们以<code>compareAndSwapInt</code> 为例，这个方法有四个参数：</p>
<ul>
<li>Object obj，类实例对象；</li>
<li>long offset，变量相当于类实例对象的偏移地址（obj+offset定位int变量的内存地址）；</li>
<li>int expect，预期当前int值；</li>
<li>int update，即将更新int值。</li>
</ul>
<blockquote>
<p>如果有一点C语言知识，就很好理解这种定位内存地址的方法了。</p>
</blockquote>
<p>我们再来看一下<code>getAndAddInt</code> 方法，也很好理解</p>
<ul>
<li><code>getIntVolatile(obj, offset)</code> 方法可以理解为读取int变量的值（obj+offset定位int变量的内存地址）；</li>
<li>首先，读取内存中变量的当前值放入expect中；</li>
<li>下一步，执行compareAndSwapInt()，比较并交换，预期当前值为expect，新值为expect+update；</li>
<li>如果compareAndSwapInt()成功直接返回；</li>
<li>如果compareAndSwapInt()失败，重新尝试，直至成功为止。</li>
</ul>
<p>再来看一下Unsafe的源码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sun::misc::Unsafe::compareAndSwapInt (jobject obj, jlong offset, jint expect, jint update)</span><br><span class="line">&#123;</span><br><span class="line">  jint *addr = (jint *)((<span class="keyword">char</span> *)obj + offset);</span><br><span class="line">  <span class="keyword">return</span> compareAndSwap(addr, expect, update);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">compareAndSwap</span> <span class="params">(<span class="keyword">volatile</span> jint *addr, jint old, jint new_val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  jboolean result = <span class="literal">false</span>;</span><br><span class="line">  spinlock lock;</span><br><span class="line">  <span class="keyword">if</span> ((result = (*addr == old)))</span><br><span class="line">    *addr = new_val;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h4><p>CAS存在一个很明显的问题，即ABA问题。也就是说，compare时虽然内存地址上的值是A，与compareAndSwap前读取到的值一样，但这不能说明内存值没有变化，可能发生了A-&gt;B-&gt;A的变化。</p>
<p>ABA问题本身不难理解，但是这样就一定出问题吗？对于数值来说，一般也没啥问题。但是，对于链表来说就有问题了。例如：</p>
<ul>
<li>线程1读取当前链表结构为A-&gt;B，head指向A，线程1试图执行compareAndSwap(A, B)，将链表头指针head指向A的下一个元素B；</li>
<li>当线程1读取链表完成执行compareAndSwap前被挂起，线程2开始执行；</li>
<li>线程2从链表中删除了元素A和元素B，又加入了元素A和元素C，链表结构为A-&gt;C；</li>
<li>此时线程1开始执行，头指针head还是执行C，但链表内容已经变了；如果还是执行head=B就出错了。</li>
</ul>
<p>ABA问题一般通过加入版本号或者时间戳就可以解决。</p>
<h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><h3 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h3><p>明白了CAS原理，AtomicInteger类就很容易理解了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util.concurrent.atomic;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicInteger</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    valueOffset = unsafe.objectFieldOffset(AtomicInteger.class.getDeclaredField(<span class="string">"value"</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">AtomicInteger</span><span class="params">(<span class="keyword">int</span> initialValue)</span> </span>&#123;</span><br><span class="line">    value = initialValue;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们以getAndIncrement()方法为例，目标为实现自增加1操作：</p>
<ul>
<li>在AtomicInteger类构造时获取了Unsafe单例，并计算value变量的内存地址偏移量valueOffset；</li>
<li>当调用自增+1方法时，实际调用了Unsafe的getAndAddInt()方法，前两个参数定位到类实例对象的value变量内存地址，变化值为1；</li>
<li>getAndAddInt()方法在CAS中介绍过，一直尝试compareAndSwapInt()，直到成功为止；<ul>
<li>读取value变量的当前值；</li>
<li>执行比较和交换操作，预期值为刚刚读到的value值，更新值为value+1；</li>
<li>如果没有其他线程竞争，那么成功写入value+1；</li>
<li>如果已经有其他线程修改了value的内存值，那么比较和交换操作失败；重新读取value变量值重试比较和交换；</li>
<li>理论上，如果一直有其他线程在修改，会陷入死循环出不来？</li>
</ul>
</li>
</ul>
<p>AtomicInteger类存在ABA问题，并行包提供了带时间戳的AtomicStampedReference类解决ABA问题。</p>
<h3 id="AbstractQueuedSynchronizer"><a href="#AbstractQueuedSynchronizer" class="headerlink" title="AbstractQueuedSynchronizer"></a>AbstractQueuedSynchronizer</h3><h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p>ReentrantLock顾名思义表示可重入锁，一般视为synchronized的替代者。</p>
<p>废话不说，直接上代码，从代码中可以看出：</p>
<ul>
<li>ReentrantLock有两种实现：公平锁FairSync和非公平锁NonfairSync。</li>
<li>默认实现是非公平锁NonfairSync；</li>
<li>构造ReentrantLock对象时可以传入boolean型参数fair显示指定使用公平锁还是非公平锁；</li>
<li>无论公平锁还是非公平锁都集成AbstractQueuedSynchronizer类；</li>
<li>结论：关键看AbstractQueuedSynchronizer、FairSync和NonfairSync三个类如何实现。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util.concurrent.locks;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">  &#125;  	</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;&#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="NonfairSync"><a href="#NonfairSync" class="headerlink" title="NonfairSync"></a>NonfairSync</h3><p>ReentrantLock类的默认实现是NonfairSync，我们先看非公平锁。NonfairSync是ReentrantLock的静态内部类。</p>
<p>我们发现NonfairSync类非常简单，以下已经是这个类的全部代码，核心实现不再这里，继续向下深入。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">      setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      acquire(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看了AbstractQueuedSynchronizer代码以后，我们解释一下lock()方法</p>
<ul>
<li><p>compareAndSetState()是Unsafe的一个CAS方法，AQS初始化的state=0，lock()将state=1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util.concurrent.locks;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span> <span class="keyword">extends</span> <span class="title">AbstractOwnableSynchronizer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> stateOffset;</span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    stateOffset = unsafe.objectFieldOffset</span><br><span class="line">      (AbstractQueuedSynchronizer.class.getDeclaredField(<span class="string">"state"</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// See below for intrinsics setup to support this</span></span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>第一步相当于抢占了一个开关，抢到以后把当前线程对象赋值给了AQS对象作为当前排他线程，仅此而已；</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util.concurrent.locks;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractOwnableSynchronizer</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> Thread exclusiveOwnerThread;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setExclusiveOwnerThread</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">    exclusiveOwnerThread = thread;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> Thread <span class="title">getExclusiveOwnerThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> exclusiveOwnerThread;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>第二次执行lock()方法时，compareAndSetState()由于stateOffset=1和预期值0不一样，返回false，进入acquire(1)逻辑；acquire()是AbstractQueuedSynchronizer类的方法，tryAcquire()回到NonfairSync类执行nonfairTryAcquire(1)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util.concurrent.locks;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span> <span class="keyword">extends</span> <span class="title">AbstractOwnableSynchronizer</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">      selfInterrupt();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>nonfairTryAcquire()是基类Sync的方法，从基类AbstractQueuedSynchronizer中getState()；由于之前lock()时已经将AQS置为1，这里c==1且current !=  exclusiveOwnerThread，返回false；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">        setExclusiveOwnerThread(current);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">      <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">      <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">      setState(nextc);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util.concurrent.locks;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span> <span class="keyword">extends</span> <span class="title">AbstractOwnableSynchronizer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span> </span>&#123;</span><br><span class="line">    state = newState;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>tryAcquire()返回false，执行acquireQueued(addWaiter(Node.EXCLUSIVE), 1)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util.concurrent.locks;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span> <span class="keyword">extends</span> <span class="title">AbstractOwnableSynchronizer</span> </span>&#123;    </span><br><span class="line">  <span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">      node.prev = pred;</span><br><span class="line">      <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">        pred.next = node;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="AQS-1"><a href="#AQS-1" class="headerlink" title="AQS"></a>AQS</h3><p>AbstractQueuedSynchronizer类就是与CAS齐名、大名鼎鼎的AQS。</p>
<p>先看AbstractQueuedSynchronizer基类AbstractOwnableSynchronizer，基类很简单，只记录一个线程对象，从变量名看这个线程对象是排他的。</p>
<blockquote>
<p>这里的transient是不参加序列化的意思。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util.concurrent.locks;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractOwnableSynchronizer</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> Thread exclusiveOwnerThread;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setExclusiveOwnerThread</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">    exclusiveOwnerThread = thread;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> Thread <span class="title">getExclusiveOwnerThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> exclusiveOwnerThread;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是AbstractQueuedSynchronizer代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util.concurrent.locks;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span> <span class="keyword">extends</span> <span class="title">AbstractOwnableSynchronizer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> stateOffset;</span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    stateOffset = unsafe.objectFieldOffset</span><br><span class="line">      (AbstractQueuedSynchronizer.class.getDeclaredField(<span class="string">"state"</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span> </span>&#123;</span><br><span class="line">    state = newState;</span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// See below for intrinsics setup to support this</span></span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">      selfInterrupt();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><p>lock时，调用AQS的compareAndSetState(0,1)方法将AQS的state=1，</p>
<p>AQS</p>
<p>Java并行包的锁机制基于AQS框架实现</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.cnblogs.com/xrq730/p/4979021.html" target="_blank" rel="noopener">ReentrantLock实现原理深入探究</a></p>
<p><a href="http://www.cnblogs.com/nullllun/p/9004309.html" target="_blank" rel="noopener">Java 重入锁 ReentrantLock 原理分析</a></p>
<p><a href="http://www.coolblog.xyz/2018/05/01/AbstractQueuedSynchronizer-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90-%E7%8B%AC%E5%8D%A0-%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">AbstractQueuedSynchronizer 原理分析 - 独占/共享模式</a></p>
<p><a href="https://segmentfault.com/a/1190000008471362" target="_blank" rel="noopener">https://segmentfault.com/a/1190000008471362</a></p>
</div><div class="tags"><a href="/tags/Reentrantlock/">Reentrantlock</a></div><div class="post-nav"><a class="pre" href="/2018/05/18/springboot-devtool-deploy/">SpringBoot热部署</a><a class="next" href="/2018/05/16/thread-basic-java-concurrent/">Java并行包</a></div><div id="vcomment"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script><script>var notify = 'false' == true ? true : false;
var verify = 'false' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'5mrT8f80zgJVcJvIPrSGzFjV-gzGzoHsz',
  appKey:'Db9rWWROewfegKQJkbYncKt1',
  placeholder:'请在这里留下你要说的话',
  avatar:'mm',
  guest_info:guest_info,
  pageSize:'10'
})</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JAVA/">JAVA</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/WEB/">WEB</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/分布式/">分布式</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/工具/">工具</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/并发编程/">并发编程</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/消息队列/">消息队列</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/">设计模式</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/索引/" style="font-size: 15px;">索引</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/mq/" style="font-size: 15px;">mq</a> <a href="/tags/rocketmq/" style="font-size: 15px;">rocketmq</a> <a href="/tags/并发/" style="font-size: 15px;">并发</a> <a href="/tags/线程/" style="font-size: 15px;">线程</a> <a href="/tags/线程池/" style="font-size: 15px;">线程池</a> <a href="/tags/任务调度/" style="font-size: 15px;">任务调度</a> <a href="/tags/多线程/" style="font-size: 15px;">多线程</a> <a href="/tags/排队策略/" style="font-size: 15px;">排队策略</a> <a href="/tags/饱和策略/" style="font-size: 15px;">饱和策略</a> <a href="/tags/synchronized/" style="font-size: 15px;">synchronized</a> <a href="/tags/wait/" style="font-size: 15px;">wait</a> <a href="/tags/notify/" style="font-size: 15px;">notify</a> <a href="/tags/内存模型/" style="font-size: 15px;">内存模型</a> <a href="/tags/内存可见性/" style="font-size: 15px;">内存可见性</a> <a href="/tags/指令重排序/" style="font-size: 15px;">指令重排序</a> <a href="/tags/Database/" style="font-size: 15px;">Database</a> <a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/Sharding/" style="font-size: 15px;">Sharding</a> <a href="/tags/单例/" style="font-size: 15px;">单例</a> <a href="/tags/线程安全/" style="font-size: 15px;">线程安全</a> <a href="/tags/分布式/" style="font-size: 15px;">分布式</a> <a href="/tags/SnowFlake/" style="font-size: 15px;">SnowFlake</a> <a href="/tags/github/" style="font-size: 15px;">github</a> <a href="/tags/WEB/" style="font-size: 15px;">WEB</a> <a href="/tags/短地址/" style="font-size: 15px;">短地址</a> <a href="/tags/哈希/" style="font-size: 15px;">哈希</a> <a href="/tags/hashCode/" style="font-size: 15px;">hashCode</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/Hashmap/" style="font-size: 15px;">Hashmap</a> <a href="/tags/哈希冲突/" style="font-size: 15px;">哈希冲突</a> <a href="/tags/mybatis/" style="font-size: 15px;">mybatis</a> <a href="/tags/ConcurrentHashMap/" style="font-size: 15px;">ConcurrentHashMap</a> <a href="/tags/SpringBoot/" style="font-size: 15px;">SpringBoot</a> <a href="/tags/热部署/" style="font-size: 15px;">热部署</a> <a href="/tags/Reentrantlock/" style="font-size: 15px;">Reentrantlock</a> <a href="/tags/Spring/" style="font-size: 15px;">Spring</a> <a href="/tags/IoC/" style="font-size: 15px;">IoC</a> <a href="/tags/springboot/" style="font-size: 15px;">springboot</a> <a href="/tags/AOP/" style="font-size: 15px;">AOP</a> <a href="/tags/注解/" style="font-size: 15px;">注解</a> <a href="/tags/动态代理/" style="font-size: 15px;">动态代理</a> <a href="/tags/反射/" style="font-size: 15px;">反射</a> <a href="/tags/泛型/" style="font-size: 15px;">泛型</a> <a href="/tags/Mybatis/" style="font-size: 15px;">Mybatis</a> <a href="/tags/Spring-Cloud/" style="font-size: 15px;">Spring Cloud</a> <a href="/tags/Eureka/" style="font-size: 15px;">Eureka</a> <a href="/tags/服务治理/" style="font-size: 15px;">服务治理</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/06/06/springcloud-eureka/">Spring Cloud - Eureka</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/05/spring-ioc-inside/">Spring-IoC原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/spring-ioc-advanced/">Spring-IoC进阶</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/31/mybatis-aop/">Mybatis动态代理原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/29/java-basic-generic/">Java基础-泛型</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/28/java-basic-proxy/">Java基础-动态代理</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/28/java-basic-annotation/">Java基础-注解</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/28/java-basic-reflect/">Java基础-反射</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/27/spring-aop/">Spring-AOP</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/22/spring-ioc/">Spring-IoC</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://github.com/waterlu" title="waterlu's github" target="_blank">waterlu's github</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">Waterlu's Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>