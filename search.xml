<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[多线程(3) ThreadPoolExecutor]]></title>
    <url>%2F2018%2F04%2F24%2Fthread-threadpoolexecutor%2F</url>
    <content type="text"><![CDATA[原理理解了ThreadPoolExecutor类的各个参数和内部原理也就理解了线程池机制。 构造参数public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123;&#125; 先来看ThreadPoolExecutor类的参数 参数名称 含义 详解 corePoolSize 核心线程数 当前线程数小于corePoolSize时，会一直创建新线程 maximumPoolSize 最大线程数 最多可以创建maximumPoolSize个线程，超过进入饱和策略 keepAliveTime 空闲时间 当超过corePoolSize时，回收线程时使用 unit 时间单位 配合keepAliveTime一起使用 workQueue 排队策略 最重要，排队策略决定了线程池的处理流程 threadFactory 工厂 创建线程时进行自定义操作 handler 饱和策略 配合workQueue使用，处理线程池满的情况 处理流程 基本逻辑 当线程池里面的线程数小于corePoolSize时，不管当前线程池中的线程是否空闲，都创建新的线程来执行任务，并加入到线程池中；这样随着任务的增加，线程池的线程数会达到corePoolSize个； 达到corePoolSize后，当新任务到来时，会选择空闲的线程来执行； 如果没有空闲线程，进入排队策略，不同的排队策略有不同逻辑； 当核心线程空闲时，会从排队队列中取出任务来执行； 当核心线程没有空闲，并且排队队列满时，创建新线程执行任务，最大不超过maximumPoolSize个； 当达到maximumPoolSize个线程，且都在忙，新任务到来时进入饱和策略，不同的饱和策略有不同逻辑；如果没有配置饱和策略，抛出RejectedExecutionException异常； 当线程数超过corePoolSize后，启动回收逻辑，空闲时间超过keepAliveTime的线程将被回收；回收时不区分核心线程和非核心线程，减少到corePoolSize个后不再回收。 排队策略不同，处理流程也不同，下面分别介绍常见三种排队策略的处理流程：SynchronousQueue、ArrayBlockingQueue和LinkedBlockingQueue。 SynchronousQueue简单说就是没有排队队列，或者队列长度为0，所以通常使用SynchronousQueue作为排队策略时，为避免出现线程执行被拒绝的情况，maximumPoolSize的值会被设置的很大。 ArrayBlockingQueue有界排队队列，必须设置队列长度；当线程数达到corePoolSize时，开始排队；当排队队列满时增加非核心线程直到maximumPoolSize。 LinkedBlockingQueueLinkedBlockingQueue如果不指定队列大小，那么就是无界队列；除非系统资源耗尽，将无限增加队列长度，因此无界队列不存在队列满的情况，也就没有非核心线程、饱和逻辑和线程回收逻辑；也就是说当设置workQueue为LinkedBlockingQueue时，keepAliveTime、unit和handler三个参数失效。 LinkedBlockingQueue也可以设置队列大小，就成了有界队列，和ArrayBlockingQueue的处理逻辑一样。 代码示例背景每个任务开始时输出“run”，结束时输出“exit”，不做具体逻辑，只是sleep1秒钟。 public static class Task implements Runnable &#123; @Override public void run() &#123; LOGGER.info("run"); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; LOGGER.info("exit"); &#125;&#125; 主线程 核心线程数2个，最大线程数4个，保活时间3秒 依次启动6个任务，每启动一个任务后都输出线程池大小 启动任务错误时输出异常信息 6个任务都启动完成后sleep 5秒，退出前再次输出线程池大小 public class ThreadExecutor &#123; private final static Logger LOGGER = LoggerFactory.getLogger(ThreadExecutor.class); public static void main(String[] args) &#123; int coreSize = 2; int maxSize = 4; long time = 3; TimeUnit unit = TimeUnit.SECONDS; ThreadPoolExecutor executor = new ThreadPoolExecutor(coreSize, maxSize, time, unit, queue, handler); for (int i=0; i&lt;6; i++) &#123; Task task = new Task(); try &#123; executor.submit(task); &#125; catch (Exception e) &#123; LOGGER.error(e.getClass().getSimpleName()); &#125; LOGGER.info("poolSize=" + executor.getPoolSize()); &#125; try &#123; Thread.sleep(5000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; LOGGER.info("poolSize=" + executor.getPoolSize()); LOGGER.info("exit"); &#125;&#125; 下面看看不同的workQueue和handler配置下的输出结果 测试结果无界队列LinkedBlockingQueue&lt;Runnable&gt; queue = new LinkedBlockingQueue&lt;&gt;(); 10:57:33:055 [pool-2-thread-1] run10:57:33:055 [main] poolSize=110:57:33:055 [main] poolSize=210:57:33:055 [main] poolSize=210:57:33:055 [pool-2-thread-2] run10:57:33:055 [main] poolSize=210:57:33:055 [main] poolSize=210:57:33:055 [main] poolSize=210:57:34:068 [pool-2-thread-2] exit10:57:34:068 [pool-2-thread-1] exit10:57:34:068 [pool-2-thread-1] run10:57:34:068 [pool-2-thread-2] run10:57:35:081 [pool-2-thread-1] exit10:57:35:081 [pool-2-thread-2] exit10:57:35:081 [pool-2-thread-1] run10:57:35:081 [pool-2-thread-2] run10:57:36:082 [pool-2-thread-1] exit10:57:36:082 [pool-2-thread-2] exit10:57:38:056 [main] poolSize=210:57:38:056 [main] exit 从日志中可以看出 当线程池达到核心线程数2后，一直保持在核心线程数不变 pool-2-thread-1和pool-2-thread-2顺序从队列中取出任务依次执行 有界队列ArrayBlockingQueue&lt;Runnable&gt; queue = new ArrayBlockingQueue&lt;&gt;(2);// LinkedBlockingQueue&lt;Runnable&gt; queue = new LinkedBlockingQueue&lt;&gt;(2); 11:01:23:147 [main] poolSize=111:01:23:147 [pool-2-thread-1] run11:01:23:147 [main] poolSize=211:01:23:147 [main] poolSize=211:01:23:147 [pool-2-thread-2] run11:01:23:147 [main] poolSize=211:01:23:147 [main] poolSize=311:01:23:147 [main] poolSize=411:01:23:147 [pool-2-thread-3] run11:01:23:147 [pool-2-thread-4] run11:01:24:147 [pool-2-thread-1] exit11:01:24:147 [pool-2-thread-1] run11:01:24:147 [pool-2-thread-2] exit11:01:24:147 [pool-2-thread-2] run11:01:24:147 [pool-2-thread-3] exit11:01:24:147 [pool-2-thread-4] exit11:01:25:158 [pool-2-thread-2] exit11:01:25:158 [pool-2-thread-1] exit11:01:28:154 [main] poolSize=211:01:28:154 [main] exit 从日志中可以看出 当队列（2个）满以后，增加了非核心线程pool-2-thread-3和pool-2-thread-4 核心线程pool-2-thread-1和pool-2-thread-2执行完第一个任务后，又从队列中取出第二个任务执行 主线程退出前线程池大小又回到了核心线程数，说明空闲线程已经被释放 同步移交+AbortSynchronousQueue&lt;Runnable&gt; queue = new SynchronousQueue&lt;&gt;();RejectedExecutionHandler handler = new ThreadPoolExecutor.AbortPolicy(); 11:07:26:130 INFO [main] poolSize=111:07:26:130 INFO [pool-2-thread-1] run11:07:26:132 INFO [main] poolSize=211:07:26:132 INFO [main] poolSize=311:07:26:132 INFO [pool-2-thread-2] run11:07:26:133 INFO [main] poolSize=411:07:26:133 ERROR [main] RejectedExecutionException11:07:26:133 INFO [main] poolSize=411:07:26:134 ERROR [main] RejectedExecutionException11:07:26:134 INFO [main] poolSize=411:07:26:135 INFO [pool-2-thread-3] run11:07:26:135 INFO [pool-2-thread-4] run11:07:27:143 INFO [pool-2-thread-3] exit11:07:27:143 INFO [pool-2-thread-2] exit11:07:27:143 INFO [pool-2-thread-4] exit11:07:27:143 INFO [pool-2-thread-1] exit11:07:31:150 INFO [main] poolSize=211:07:31:150 INFO [main] exit 从日志中可以看出 当线程数到达最大线程数4个以后，再提交的任务抛出了RejectedExecutionException异常 所以与前面的结果不同，这次只执行了4个任务 最后空闲线程被回收，线程数保持在2个 AbortPolicy是默认的饱和策略 以下已空队列为例，更换饱和策略 同步移交+DiscardSynchronousQueue&lt;Runnable&gt; queue = new SynchronousQueue&lt;&gt;();RejectedExecutionHandler handler = new ThreadPoolExecutor.DiscardPolicy(); 11:12:20:113 INFO [pool-2-thread-1] run11:12:20:113 INFO [main] poolSize=111:12:20:113 INFO [main] poolSize=211:12:20:113 INFO [pool-2-thread-2] run11:12:20:113 INFO [main] poolSize=311:12:20:113 INFO [main] poolSize=411:12:20:113 INFO [pool-2-thread-3] run11:12:20:113 INFO [main] poolSize=411:12:20:113 INFO [main] poolSize=411:12:20:113 INFO [pool-2-thread-4] run11:12:21:128 INFO [pool-2-thread-4] exit11:12:21:128 INFO [pool-2-thread-2] exit11:12:21:128 INFO [pool-2-thread-3] exit11:12:21:128 INFO [pool-2-thread-1] exit11:12:25:119 INFO [main] poolSize=211:12:25:119 INFO [main] exit 对比上面的日志可以发现 同样也是只执行了4个任务 区别在于没有抛出异常，也就是说Discard策略直接拒绝，来异常都不给，没啥用 同步移交+CallerRunSynchronousQueue&lt;Runnable&gt; queue = new SynchronousQueue&lt;&gt;();RejectedExecutionHandler handler = new ThreadPoolExecutor.CallerRunsPolicy(); 11:18:11:432 INFO [pool-2-thread-1] run11:18:11:432 INFO [main] poolSize=111:18:11:434 INFO [main] poolSize=211:18:11:434 INFO [pool-2-thread-2] run11:18:11:434 INFO [main] poolSize=311:18:11:435 INFO [main] poolSize=411:18:11:435 INFO [main] run11:18:11:435 INFO [pool-2-thread-3] run11:18:11:435 INFO [pool-2-thread-4] run11:18:12:447 INFO [pool-2-thread-4] exit11:18:12:447 INFO [main] exit11:18:12:447 INFO [pool-2-thread-3] exit11:18:12:447 INFO [pool-2-thread-2] exit11:18:12:447 INFO [pool-2-thread-1] exit11:18:12:447 INFO [main] poolSize=411:18:12:447 INFO [main] run11:18:13:448 INFO [main] exit11:18:13:448 INFO [main] poolSize=411:18:18:454 INFO [main] poolSize=211:18:18:454 INFO [main] exit 从日志中可以看出 当线程数到达最大线程数4个以后，第5个任务开始在main线程中执行 CallerRunsPolic保证了线程不会被丢弃，但交给主线程运行没有起到线程池的作用，应该也不常用 实战Executorspackage java.util.concurrent;public class Executors &#123; public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;())); &#125; public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()); &#125; public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;()); &#125; &#125; Executors类提供了常用线程池的创建方法，不过不建议使用Executors来创建线程池，因为这会隐藏最终创建ThreadPoolExecutor类的参数，还是建议手工构造ThreadPoolExecutor，显示指定参数。下面详细看看三个预定义的线程池： SingleThread，顾名思义，线程池的核心和最大线程数都是1，无界排队策略；也就是说这个线程池中只有1个线程，其他并发线程排队等待，线程池一个一个来处理，简单，但是效率比较低； FixedThread，线程池的核心线程数与最大线程数保持一致，无界排队策略；也就是说这个线程池中没有非核心线程，最多可以同时处理N个任务，其他任务排队等待；SingleThread可以看作N=1的FixedThread； CachedThread，核心线程数0，最大线程数无穷大，无排队队列，保活时间60秒；也就是说这个线程池中的线程数是动态变化的，当有新任务时就创建新线程来处理（当前线程都在忙），处理完成后1分钟回收线程；如果没有任务，线程数就是0，如果任务非常多，线程数无限增加，直到耗尽系统资源。 以上可以看出，Executors默认提供的几种线程池比较极端，实战中需要自定义ThreadPoolExecutor。 核心线程数虽然排队策略看上去比较复杂，但我认为ThreadPoolExecutor最重要的参数是核心线程数；因为考虑到不拒绝任何任务，我们可以使用LinkedBlockingQueue实现无界队列，这样其他参数基本就都失效了，而核心线程数即使当前没有任务也要保留，就变得异常重要的。 确定核心线程数，一般的思路是根据任务性质来判断的。如果是计算密集型任务，那么通常核心线程数设置为CPU个数+1，通过Runtime.getRuntime().availableProcessors();可以读取CPU个数。如果是I/O密集型任务，那么中断会多一些，核心线程数也可以多一些，一般可以设置为CPU个数的2倍。 Apache MINA 的核心线程数设置为CPU个数+1s=>start: 开始 e=>end: 结束 condCore=>condition: 小于核心线程数? condMax=>condition: 小于最大线程数? addCore=>operation: 增加核心线程 addNormal=>operation: 增加非核心线程 full=>operation: 饱和逻辑处理 s->condCore condCore(yes, right)->addCore condCore(no)->condMax condMax(yes, right)->addNormal condMax(no)->full addNormal->e addCore->e full->e{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12,"theme":"simple"} var code = document.getElementById("flowchart-0-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value)); var diagram = flowchart.parse(code); diagram.drawSVG("flowchart-0", options);s=>start: 开始 e=>end: 结束 condCore=>condition: 小于核心线程数? condQueue=>condition: 队列未满? condMax=>condition: 小于最大线程数? addCore=>operation: 增加核心线程 addNormal=>operation: 增加非核心线程 addQueue=>operation: 排队等待执行 full=>operation: 饱和逻辑处理 s->condCore condCore(yes, right)->addCore condCore(no)->condQueue condQueue(yes, right)->addQueue condQueue(no)->condMax condMax(yes, right)->addNormal condMax(no)->full addQueue->e addNormal->e addCore->e full->e{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12,"theme":"simple"} var code = document.getElementById("flowchart-1-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-1-options").value)); var diagram = flowchart.parse(code); diagram.drawSVG("flowchart-1", options);s=>start: 开始 e=>end: 结束 condCore=>condition: 小于核心线程数? addCore=>operation: 增加核心线程 addQueue=>operation: 排队等待执行 s->condCore condCore(yes)->addCore condCore(no)->addQueue addQueue->e addCore->e{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12,"theme":"simple"} var code = document.getElementById("flowchart-2-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-2-options").value)); var diagram = flowchart.parse(code); diagram.drawSVG("flowchart-2", options);]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发</tag>
        <tag>线程</tag>
        <tag>线程池</tag>
        <tag>排队策略</tag>
        <tag>饱和策略</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程(2) 线程池]]></title>
    <url>%2F2018%2F04%2F24%2Fthread-threadpool%2F</url>
    <content type="text"><![CDATA[任务调度任务是一组逻辑工作单元，线程则是任务异步执行的机制。前面说过，实战中我们不会直接调用Thread类的start()方法来启动线程，那么线程应该如何启动呢？ Executor使用Executor.execute(task);来替代new Thread(task).start(); package java.util.concurrent;public interface Executor &#123; void execute(Runnable command);&#125; Executor将任务提交给线程池来处理，线程池的处理是异步的，任务会交给新的线程来执行，本地线程可以继续做其他事情。 ExecutorServiceExecutor只有一个没有返回值的接口execute()，为了更好的控制线程的行为，并行包中为我们提供了功能更强大的ExecutorService，实际使用过程中，更多使用的是ExecutorService的接口。 package java.util.concurrent;public interface ExecutorService extends Executor &#123; &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task); Future&lt;?&gt; submit(Runnable task); &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result); void shutdown(); List&lt;Runnable&gt; shutdownNow();&#125; 下面详细看一下ExecutorService的几个接口 submit提交任务有三个接口，区别在于任务类实现了哪个接口，以及是否需要读取返回结果 Callable：下面的例子用来计算1+2+…+N的和，任务完成后返回计算结果 public class Task implements Callable&lt;Integer&gt; &#123; private int count = 0; public Task(int count) &#123; this.count = count; &#125; @Override public Integer call() throws Exception &#123; int sum = 0; for (int i=1; i&lt;=count; i++) &#123; sum += i; &#125; LOGGER.info("done"); return sum; &#125;&#125; 再来看看任务调度，通过future.get()可以获取返回的计算结果55。future.get()是一个阻塞方法，如果task线程执行需要很长时间，那么main线程将会停在这里一直到task线程处理完成。 ExecutorService executor = Executors.newSingleThreadExecutor();Task task = new Task(10);Future&lt;Integer&gt; future = executor.submit(task);Integer result = future.get();LOGGER.info("result=" + result); 这里和new Thread().start()没有本质的区别，都达到相同的效果，区别在于这里使用了线程池。 Runnable：完成相同的功能，由于run()方法没有返回值，我们在构造Task对象时增加了Data参数 public class Task implements Runnable &#123; private final Data data; private int count = 0; public Task(int count, Data data) &#123; this.count = count; this.data = data; &#125; @Override public void run() &#123; int sum = 0; for (int i=1; i&lt;=count; i++) &#123; sum += i; &#125; data.setResult(sum); &#125;&#125;public static class Data &#123; private Integer result; public Integer getResult() &#123; return result; &#125; public void setResult(Integer result) &#123; this.result = result; &#125; &#125; 再来看看任务调度，通过future.get()可以获得Data对象，然后从Data对象中获取计算结果55。 这里调用的是submit(Runnable task, T result)方法，如果调用submit(Runnable task)方法是无法获取到计算结果的，future.get()返回null，只能表明计算任务已经完成。 ExecutorService executor = Executors.newSingleThreadExecutor();Data data = new Data();Task task = new Task(10, data);Future&lt;Data&gt; future = executor.submit(task, data);Integer result = future.get().getResult();LOGGER.info("result=" + result); 这里重点演示submit()的用法，线程池使用了最简单的SingleThreadExecutor shutdownshutdown()方法在关闭ExecutorService之前等待提交的任务执行完成，shutdownNow()方法阻止开启新的任务并且尝试停止当前正在执行的线程。 ThreadPoolExecutor平时我们最常用到的是ThreadPoolExecutor类，它实现了ExecutorService接口。 package java.util.concurrent;public class ThreadPoolExecutor extends AbstractExecutorService &#123;&#125; package java.util.concurrent;public abstract class AbstractExecutorService implements ExecutorService &#123;&#125; 我们知道，Executor接口含有execute()方法，ExecutorService接口含有submit()方法，这样就有两种方法提交任务给线程池ThreadPoolExecutor执行。当我们不关注任务的返回结果时，可以通过execute()方法提交任务；当我们需要拿到任务的返回结果时，就必须通过submit()方法提交任务了。 除了get()方法可以得到返回结果以外，Future类还提供了其他方法来查询线程的执行状态，所以当我们关系任务的执行状态时，也应该使用submit()，个人建议可以都使用submit()来提交任务。另外，submit()最后还是执行的execute()，只不过执行前做了Future的准备工作。 public abstract class AbstractExecutorService implements ExecutorService &#123; public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) &#123; if (task == null) throw new NullPointerException(); RunnableFuture&lt;T&gt; ftask = newTaskFor(task); execute(ftask); return ftask; &#125; protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Callable&lt;T&gt; callable) &#123; return new FutureTask&lt;T&gt;(callable); &#125; &#125;public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; &#123; void run();&#125;public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt; &#123; public V get() throws InterruptedException, ExecutionException &#123; int s = state; if (s &lt;= COMPLETING) s = awaitDone(false, 0L); return report(s); &#125; &#125; TODO: Future原理]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发</tag>
        <tag>线程</tag>
        <tag>线程池</tag>
        <tag>任务调度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程(1) 线程状态]]></title>
    <url>%2F2018%2F04%2F24%2Fconcurrent-thread%2F</url>
    <content type="text"><![CDATA[线程进程与线程提到线程大家就会想起进程，先来看看进程和线程的联系和区别。 什么是进程？ 通俗的讲，进程就是操作系统中运行的程序，当你的程序代码被操作系统加载到内存中运行的时候，它就成为了一个进程。以Linux系统为例，每个进程有自己的进程号(pid)，有独立的地址空间。每个进程有独立的地址空间意味着，一个进程不能够访问到另外一个进程的内存空间，内存地址空间是进程私有的。 进程间可以通过共享内存通信，共享内存空间并非进程私有的。 什么是线程? 线程理解起来比进程要抽象一些。线程与操作系统的任务调用相关，可以简单认为线程是操作系统任务调度的基本单位。现在的大部分操作系统采用的都是时间片和抢占式的任务调用机制，当多个任务共享CPU资源时，一个任务执行一段时间后被挂起(这个任务执行的这段时间就称为时间片)，切换到另外一个任务开始执行。通常任务调度的单位不是进程，而是线程，也就是说，线程是进程可以独立交给CPU执行的一个任务。线程有自己的栈和程序计数器。 这样，一个进程可以包含多个线程，每个线程作为一个任务交给操作系统调用。实际上，Java进程至少要包含一个线程，如果我们没有显示的创建线程，main()方法是在[main]线程中执行的。对于Java进程来说，每个线程有自己的栈空间，多个线程共享进程的堆空间。 JAVA线程通常有三种创建线程的方法：继承Thread类，实现Runnable接口和实现Callable接口。继承Thread类和实现Runnable接口都需要实现run()方法，实现Callable接口需要实现call()方法。继承Thread类的，直接调用start()方法就可以启动线程；实现Runnable接口的，需要new Thread(task).start()启动线程；实现Callable接口的，需要new Thread(new FutureTask&lt;&gt;(task)).start()启动线程。 实战中，我们不会直接使用new Thread().start()来启动线程，而是交给Executor去处理。因为每次new一个新的线程显然是低效的，放到线程池里执行是更好的选择。同样原因，实际编码中很少使用继承Thread类的办法来创建线程，因为Executor只接收接口。并且，由于Java不支持多重继承，实现Runnable接口显然是比继承Thread类更好的设计。 实战中我们几乎不会使用直接继承Thread类的方式，剩下的要么实现Runnable，要么实现Callable，选择哪个取决于具体的业务需求。Callable与Runnable的不同之处在于，它可以返回结果，通俗点说，call()方法是有返回值的，run()方法是void的。所以，当需要线程执行完成后返回结果时，请选择Callable。 下面给出一个使用Callable的例子，计算1+2+…+10的和。 public class ProcessThread &#123; public static void main(String[] args) throws Exception &#123; FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;&gt;(new Callable&lt;Integer&gt;() &#123; @Override public Integer call() throws Exception &#123; int sum = 0; for (int i=1; i&lt;=10; i++) &#123; sum += i; &#125; return sum; &#125; &#125;); new Thread(futureTask).start(); System.out.println("sum=" + futureTask.get().toString()); &#125;&#125; 注意：虽然方法名字叫做start()，但是这个方法并不能保证线程立即开始执行，start()操作只能保证线程进入runnable状态，具体什么时间能够被执行由操作系统控制；futureTask.get()方法是同步等待的，等待Task的call()方法执行完成才返回。 线程是可以设置优先级的，常见的优先级有以下三种，默认为NORMAL_PRIORITY ： MAX_PRIORITY = 10-NORMAL_PRIORITY = 5-MIN_PRIORITY = 1 理论上优先级高的线程先被执行，具体情况也要看操作系统如何调度。 线程状态线程状态迁移下面的这个线程状态迁移图是比较经典的，画的很详细。 线程的几个状态 [new]：初始状态，新建一个线程对象后的状态 [runnable]：就绪状态，调用了start()方法，等待CPU资源(操作系统调度) [running]：运行状态，得到了CPU时间片，执行run()方法或者call()方法 [dead]：销毁状态，线程任务执行结束或者exit(1)强制退出 [blocked]：阻塞状态，被动失去CPU时间片，等待进入runnable状态 [waiting]：等待状态，主动失去CPU时间片，等待进入runnable状态 waiting状态和blocked状态的区别在于一个是主动交出时间片，另外一个是被动交出时间片；当然前提是已经获得了时间片，得到了执行；从runnable状态到running状态是不受程序控制的，完全靠操作系统来调度，虽然我们可以设置线程的优先级，但是不一定达到预期。 状态变化的过程： [new]：MyThread thread = new MyThread(); [new]-&gt;[runnable]：thread.start(); [runnable]-&gt;[running]：操作系统调度，runnable状态意味着任务已经做好执行的准备，但什么时间真正执行（获得时间片）需要由操作系统来控制，任务本身无法控制； [running]-&gt;[dead]：线程执行完成； [running]-&gt;[runnable]：Thread.yield(); 调用yield()方法将失去时间片，但是可以立刻进入runnable状态，运气好的话可以立刻又获得时间片进入running状态；yield()给其他任务以执行的机会； [running]-&gt;[waiting]： thread.join();调用join()方法将失去时间片，进入waiting状态，等到thread线程执行完毕后进入runnable状态； object.wait(); 调用 wait()方法将失去时间片，进入waiting状态，得到其他线程执行object.notify()方法是进入runnable状态； Thread.sleep(); 调用sleep()方法将失去时间片，进入waiting状态，sleep结束后进入runnable状态； [ruuning]-&gt;[blocked]：调用synchronized()将等待锁，进入blocked状态，得到锁以后进入runnable状态； [waiting]-&gt;[runnable]： thread.join(); 其他线程执行完成后进入runnable状态； object.wait(); 其他线程调用object.notify()或者object.notifyAll()后进入runnable状态； [blocked]-&gt;[runnable]：其他线程退出synchronized{}语句块以后进入runnable状态； 注意：区分Thread类和Object类的方法，区分静态方法和普通方法。 Thread类和Object类相关方法 package java.lang;public class Thread implements Runnable &#123; public static native Thread currentThread(); public static native void yield(); public static native void sleep(long millis) throws InterruptedException; public synchronized void start() &#123; start0(); &#125; public void interrupt() &#123; interrupt0(); &#125; public final void setPriority(int newPriority) &#123; setPriority0(priority = newPriority); &#125; private native void start0(); private native void interrupt0(); private native void setPriority0(int newPriority);&#125; package java.lang;public class Object &#123; public final native void notify(); public final native void notifyAll(); public final native void wait(long timeout) throws InterruptedException;&#125; 生产者和消费者实例通过经典的生产者和消费者的例子，可以看到Thread类和Object类如何配合，以及线程的生命周期和状态变化。 需求 两个线程，一个线程作为生产者生产商品，一个线程作为消费者消费商品； 商品有库存，当库存满时生产者暂停生产，当库存空时消费者暂停消费。 实现 主线程，创建库存列表，启动生产者线程和消费者线程 public class ProducerAndConsumer &#123; public static void main(String[] args) &#123; LinkedList&lt;String&gt; storeList = new LinkedList&lt;&gt;(); // 生产者和消费者共享库存列表 Producer producer = new Producer(storeList); Consumer consumer = new Consumer(storeList); producer.start(); consumer.start(); &#125;&#125; 生产-消费逻辑 开始库存是空的，先生产一个数据 此后如果可以抢到synchronized锁，可以继续生产数据，直到库存满 库存满了以后主动让出时间片，进入waiting状态，等待消费者notify() 如果生产完第一个数据后没有抢到synchronized锁，那么进入blocked状态，等待消费者退出synchronized代码块；当消费者完成一次消费操作退出synchronized代码块后，生产者线程进入runnable状态，等待CPU调度；抢到CPU时间片后可以继续生产 如果生产者线程一直没有抢到CPU时间片，那么消费者一直消费（一次消费一个），直到库存空 库存空以后消费者交出时间片，生产者获得时间片，继续生产数据 生产数据后通过notify()方法唤醒消费者线程 生产者notify()方法只能保证消费者线程进入runnable状态，但不一定能抢到时间片执行 大家都是runnable状态时，谁能得到CPU时间片就看人品了，操作系统就可以这么任性 生产者 public class Producer extends Thread &#123; // 库存最大容量 private final static int MAX = 10; // 计数器，方便观察 private AtomicInteger count = new AtomicInteger(1); // 库存 private LinkedList&lt;String&gt; storeList; public Producer(LinkedList&lt;String&gt; storeList) &#123; this.storeList = storeList; &#125; @Override public void run() &#123; // 获得时间片，进入running状态 while(true) &#123; // 必须在synchronized代码块内使用wait()和notify() // 如果storeList已经被其他线程锁定，进入blocked状态 // 如果storeList没有被其他线程锁定，继续running状态 synchronized (storeList) &#123; while(storeList.size() == MAX) &#123; System.out.println("库存满了"); try &#123; // 库存满了，不能再生产了 // 让出时间片，进入waiting状态 // 操作系统负责保存当前线程状态，当恢复时从这里继续执行 storeList.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; // storeList.size() &lt; MAX 时，直接生产一个新数据 // storeList.size() = MAX 时，消费者调用storeList.notify()时, // 进入runnable状态，获得时间片后继续执行，生产一个新数据 String data = String.format("%04d", count++); storeList.add(data); System.out.println("生产 " + data); // 让出时间片，进入waiting状态 try &#123; Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; // Sleep 500毫秒后进入runnable状态，获得时间片后继续执行 // 通知消费者，如果消费者由于库存空了进入waiting状态，此时将被唤醒 storeList.notifyAll(); // 此后重新尝试进入synchronized代码块 &#125; &#125; &#125;&#125; 消费者 public class Consumer extends Thread &#123; // 库存 private LinkedList&lt;String&gt; storeList; public Consumer(LinkedList&lt;String&gt; storeList) &#123; this.storeList = storeList; &#125; @Override public void run() &#123; // 获得时间片，进入running状态 while(true) &#123; // 如果storeList已经被其他线程锁定，进入blocked状态 // 如果storeList没有被其他线程锁定，继续running状态 synchronized (storeList) &#123; while(storeList.size() == 0) &#123; System.out.println("库存空了"); try &#123; // 库存空了，不能再消费了 // 让出时间片，进入waiting状态 storeList.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; // storeList.size() &gt; 0 时，直接消费一个数据 // storeList.size() = 0 时，生产者调用storeList.notify()时, // 进入runnable状态，获得时间片后继续执行，消费一个数据 String data = storeList.get(0); System.out.println("消费 " + data); storeList.remove(0); // 让出时间片，进入waiting状态 try &#123; Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; // 通知生产者，如果生产者由于库存满了进入waiting状态，此时将被唤醒 storeList.notifyAll(); // 此后重新尝试进入synchronized代码块 &#125; &#125; &#125;&#125; 下表列出了输出结果和对应的线程状态 日志输出 Producer PC Producer状态 Consumer PC Consumer状态 生产 0001 storeList.add(); running runnable 消费 0001 synchronized () blocked storeList.remove(); running 库存空了 synchronized () blocked storeList.wait(); waiting 生产 0002 storeList.add(); running storeList.wait(); waiting 生产 0003 storeList.add(); running storeList.wait(); waiting synchronized () blocked 消费 0002 synchronized () blocked storeList.remove(); running 消费 0003 synchronized () blocked storeList.remove(); running 库存空了 synchronized () blocked storeList.wait(); waiting 生产 0004 storeList.add(); running storeList.wait(); waiting …… 生产 0013 storeList.add(); running synchronized () blocked 库存满了 storeList.wait(); waiting synchronized () blocked 消费 0004 storeList.wait(); waiting storeList.remove(); running 消费 0005 synchronized () blocked storeList.remove(); running 消费 0006 synchronized () blocked storeList.remove(); running 生产 0014 storeList.add(); running synchronized () blocked 生产 0015 storeList.add(); running synchronized () blocked 注意：每生产或者消费一个数据以后都通过storeList.notify()来唤醒对手方的storeList.wait()，但是唤醒只能保证对手方线程进入runnable状态；这个时候继续执行当前线程(notify)，还是切换到等待线程(wait)是由操作系统来调度的，是随机的。此外，由于synchronized的存在，多CPU情况下生产者和消费者也不会长期同时处于running状态，短暂同时处于running状态后，后进入synchronized代码块的线程将进入blocked状态，等待前进入的线程退出synchronized代码块。 线程实现Java线程的实现有三种策略： 内核实现，Java线程相关方法声明为native，所有操作直接调用操作系统内核的API，此时的Java线程与操作系统内核线程一一对应； 用户实现，Java线程对操作系统是透明的，自己实现线程调度； 混合实现，综合上面两种实现的折中方案。 Java线程在JDK1.2之前采用用户实现策略，之后替换为内核实现。也就是说，一个Java线程就对应操作系统一个实际的线程（轻量级进程）。 Java线程使用抢占式的调度策略，由操作系统来分配执行时间。由于各个操作系统的线程优先级粒度不一样，所以Java线程优先级设置很难与操作系统线程优先级一一对应，所以就不那么靠谱。 上图中，KLT是Kernel Thread的缩小，表示这是一个操作系统内核线程；LWP是Light Weight Process的缩写，表示轻量级进程。应用程序一般不直接使用内核线程，而是使用轻量级进程作为接口；P表示一个Java进程。 所以，上图的含义为：一个Java进程中可以创建多个线程，每个线程调用LWP接口，实际对应着一个内核线程，内核线程由操作系统调度。 Linux 2.6以后有了一种新的pthread线程库–NPTL(Native POSIX Threading Library)，hotspot虚拟机就是使用NPTL来实现多线程的。]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RocketMQ(3) 开发]]></title>
    <url>%2F2018%2F04%2F23%2Frocketmq-dev%2F</url>
    <content type="text"><![CDATA[编码配置在pom.xml引入rocketmq-client模块和rocketmq-common模块，选择合适的版本，这里我用的是3.1.4版本 https://github.com/apache/rocketmq-externals/tree/master/rocketmq-spring-boot-starter &lt;!-- rocket mq --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.rocketmq&lt;/groupId&gt; &lt;artifactId&gt;rocketmq-client&lt;/artifactId&gt; &lt;version&gt;3.1.4&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.rocketmq&lt;/groupId&gt; &lt;artifactId&gt;rocketmq-common&lt;/artifactId&gt; &lt;version&gt;3.1.4&lt;/version&gt;&lt;/dependency&gt; 发送消息 发送消息比较简单，首先创建消息生产者，指定组；然后启动生产者； 当需要发消息时调用生产者的send()方法即可，消息对象需要指定主题、标签、主键、消息体内容等信息；通过send()方法的返回值同步判断是否发送成功； 发送失败将会自动重试，重试次数和超时时间可以在创建生产者时进行设置。 package cn.waterlu.test.rocketmq; import com.alibaba.rocketmq.client.producer.DefaultMQProducer;import com.alibaba.rocketmq.client.producer.SendResult;import com.alibaba.rocketmq.common.message.Message;public class TestRocketMq &#123; @Test public void testProducer() &#123; // 生产者组的名称 String groupName = "group_producer"; // NameServer地址 String nameServer = "10.10.10.163:9876"; // 如果发送失败，重试次数 int retryTimes = 3; // 发送超时时间（毫秒） long timeout = 10000; // 创建Producer并进行配置 DefaultMQProducer producer = new DefaultMQProducer(groupName); producer.setNamesrvAddr(nameServer); producer.setRetryTimesWhenSendFailed(retryTimes); producer.setSendMsgTimeout(timeout); // 启动Producer，可复用 producer.start(); // 创建消息 // topic String 消息主题 // tag String 消息标签（可空） // key String 消息主键 // body byte [] 消息体 Message message = new Message(topic, tag, key, body); // 发送消息 SendResult sendResult = producer.send(message); SendStatus status = sendResult.getSendStatus(); // 判断发送是否成果 if (status.equals(SendStatus.SEND_OK)) &#123; logger.info("发送成功"); &#125; else &#123; logger.warn("发送失败"); &#125; &#125;&#125; 接收消息 消费消息与生产消息类似，需要首先创建消费者，设置参数，最后启动消费者消费消息； 消费者和生产者一样需要指定NamerServer地址和消费组名称； 消费者启动前需要指定订阅的主题和标签，进行消息过滤； 消费者需要注册收到消息后的处理方法； 消费者分为Pull和Push两种模式，其本质都是拉去消息； Push模式把轮询过程封装了，对用户来说，感觉消息是被推送过来的； Pull模式用户需要自己拉起消息。 package cn.waterlu.test.rocketmq;import com.alibaba.rocketmq.client.consumer.DefaultMQPushConsumer;import com.alibaba.rocketmq.client.consumer.ConsumeFromWhere;public class TestRocketMq &#123; @Test public void testConsumer() &#123; // 消费组的名字 String consumerGroupName = "group_consumer"; // NameServer地址 String nameServer = "10.10.10.163:9876"; // 创建消息者 DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(consumerGroupName); consumer.setNamesrvAddr(nameServer); // 三个选项，区别在新订阅组第一次启动时的行为不同，以后都是继续上一次的位置进行消费 // CONSUME_FROM_LAST_OFFSET 新订阅组第一次启动从队列的最后开始消费 // CONSUME_FROM_FIRST_OFFSET 新订阅组第一次启动从队列的头开始消费 // CONSUME_FROM_TIMESTAMP 新订阅组第一次启动从指定时间点开始消费 consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET); // 指定订阅的主题和标签，主题和标签都是String // 多个标签中间通过"||"分隔，例如："pay||order||clear" consumer.subscribe(topic, tags); // 注册消息处理的回掉方法 consumer.registerMessageListener(new MessageListenerConcurrently() &#123; @Override public ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt; list, ConsumeConcurrentlyContext consumeConcurrentlyContext) &#123; // consumeMessageBatchMaxSize默认值为1，所以List里面只有一个元素 MessageExt messageExt = list.get(0); // 主题 String topic = messageExt.getTopic(); // 标签 String tag = messageExt.getTags(); // 消息ID，RocketMQ自动生成 String messageID = messageExt.getMsgId(); // 消息主键，业务自己指定 String messageKey = messageExt.getKeys(); // 消息内容 byte[] messageBody = messageExt.getBody(); // CONSUME_SUCCESS 表示消息消费成功 // RECONSUME_LATER 表示消息消费失败，RocketMQ过一段时间后会重新投递消息 return ConsumeConcurrentlyStatus.CONSUME_SUCCESS; //return ConsumeConcurrentlyStatus.RECONSUME_LATER; &#125; &#125; // 启动消费组 consumer.start(); &#125;&#125;]]></content>
      <categories>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>mq</tag>
        <tag>rocketmq</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RocketMQ(2) 部署与维护]]></title>
    <url>%2F2018%2F04%2F22%2Frocketmq-deploy%2F</url>
    <content type="text"><![CDATA[由于用到了事务消息功能，所以我使用的是3.1.4版本，这是一个非常老的版本，没有使用最新的版本。RocketMQ从4.0版本开始在Apche孵化，现在最新的版本是4.2.0，预计4.3.0版本可能会增加事务消息功能。3.x的最新稳定版本是3.5.8。 RocketMQ官方版本V3.0.4~3.1.4基于文件系统实现了事务消息，已开源；V3.1.5~4.2.0基于数据库实现事务消息，未开源。 部署这里 有V3.1.4版本的源码，是作为V3.1.9的一个fork的分支存在的，以下操作都以V3.1.4版本为例，最新版本可能会不一样。 打包 环境准备：安装rocketmq前需要先安装jdk，git和maven 编译打包 $ cd rocketmq-3.1.4$ mvn -Dmaven.test.skip=true clean package install assembly:assembly -U$ cd ./target/alibaba-rocketmq-3.1.4/alibaba-rocketmq$ ls -ldrwxrwxr-x 2 lu lu 4096 Jan 20 16:34 benchmarkdrwxrwxr-x 2 lu lu 4096 Jan 20 16:34 bindrwxrwxr-x 5 lu lu 4096 Jan 20 16:34 confdrwxrwxr-x 2 lu lu 4096 Jan 20 16:34 lib-rw-rw-r-- 1 lu lu 10275 Jan 20 16:34 LICENSE.txtdrwxrwxr-x 2 lu lu 4096 Jan 20 16:34 test 启动由于默认启动参数配置的内存比较大，我们一般会先调整一下内存参数，具体为修改apache-rocketmq/bin目录下的runserver.sh和runbroker.sh脚本，修改其中的JAVA_OPT，将Xms/Xmx/Xmn等内存参数调整到合适大小 如上图所示，RocketMQ由NameServer和BrokerServer组成，其中NameServer用做注册中心，Broker启动后注册到NameServer，Producer和Consumer与NameServer通信，获取Broker的地址；Producer发送消息给Broker，Broker完成消息存储，并负责将消息投递给Consumer。 首先，启动NameServer，NameServer的服务端口为9876 $ cd target/alibaba-rocketmq-3.1.4/alibaba-rocketmq$ nohup sh bin/mqnamesrv &gt; /dev/null 2&gt;&amp;1 &amp; 然后，启动BrokerServer，其中-n参数为NameServer的地址和端口，Broker的服务端口为10911和10912，10911供Producer和Consumer通信使用，10912供Broker集群通信使用 $ cd target/alibaba-rocketmq-3.1.4/alibaba-rocketmq$ nohup sh bin/mqbroker -n localhost:9876 &gt; /dev/null 2&gt;&amp;1 &amp; Broker启动时将自己的地址和端口注册到NameServer上，但存在多网卡时，Broker有可能获取不到正确的IP地址，最后导致Producer和Consumer连接不到Broker上，出现类似下面这样的错误。 connect to &lt;172.17.0.1:10911&gt; failed 这种情况下，我们需要在Broker启动时指定IP地址，具体方法为配置一个启动参数文件broker.properties，内容如下（可以从conf/2m-noslave/broker-a.properties复制并修改）： brokerClusterName=DefaultClusterbrokerName=broker-abrokerId=0brokerIP=10.10.10.100deleteWhen=04fileReservedTime=48brokerRole=ASYNC_MASTERflushDiskType=ASYNC_FLUSH 启动脚本如下，重点在于-c参数指定了配置文件，当前如果需要我们可以在broker.properties中做更多的个性化配置 $ nohup sh bin/mqbroker -n localhost:9876 -c conf/broker.properties &gt; /dev/null 2&gt;&amp;1 &amp; 关闭关闭Broker服务 $ sh bin/mqshutdown broker 关闭NameServer服务 $ sh bin/mqshutdown namesrv 命令管理RocketMQ提供了bin/mqadmin命令行对消息队列进行管理。 -n设置NameServer地址和端口(从NameServer上获取Broker地址和端口) 查看主题列表 $ bin/mqadmin topicList -n localhost:9876TBW102 创建主题 参数 说明 -n NameServer地址和端口 -b Broker地址和端口(Topic创建在这个Broker上面) -c Cluster名称（Broker和Cluster二选一） -t Topic主题名称 -r 读队列数(默认8个) -w 写队列数(默认8个) 创建主题test $ bin/mqadmin updateTopic -n localhost:9876 -b localhost:10911 -t test -r 4 -w 4create topic to localhost:10911 success.TopicConfig [topicName=test, readQueueNums=4, writeQueueNums=4, perm=RW-, topicFilterType=SINGLE_TAG]$ bin/mqadmin topicList -n localhost:9876TBW102test 查看Topic信息 $ bin/mqadmin topicStats -n localhost:9876 -t test 查看集群信息 $ bin/mqadmin clusterList -n localhost:9876#Cluster Name #Broker Name #BID #Addr #VersionDefaultCluster ubuntu 0 172.17.0.1:10911 V3_1_4 根据MessageID查询消息 $ bin/mqadmin queryMsgById -n localhost:9876 -i 根据消息Key查询消息 $ bin/mqadmin queryMsgByKey -n localhost:9876 -t test -k 控制台虽然可以通过命令行查看RocketMQ状态，但是使用起来很不方便。 rocketmq-console项目封装了mqadmin指令，提供了web页面来展示rocketmq信息，所以通常我们都使用rocketmq-console来查看RocketMQ状态。 rocketmq-console属于rocketmq-externals 项目的一部分。 首先，获取源码 $ git clone https://github.com/apache/rocketmq-externals 然后，打包部署(rocketmq-console是spring boot项目) $ cd rocketmq-externals/rocketmq-console$ mvn clean package -Dmaven.test.skip=true$ java -jar rocketmq-console-ng-1.0.0.jar --server.port=12581 --rocketmq.config.namesrvAddr=10.89.0.64:9876 v3.1.4版本是没有提供控制台工具的，rocketmq-externals(包括rocketmq-console)是为rocketmq v4.0.0以上版本服务的。所以，理论上rocketmq-console和v3.1.4是不兼容的。不过，mqadmin的指令协议没有变化，所以基本使用是可以的。当然，升级到4.0.0以上版本就更没有问题了。]]></content>
      <categories>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>mq</tag>
        <tag>rocketmq</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RocketMQ(1) 概述]]></title>
    <url>%2F2018%2F04%2F21%2Frocketmq-intro%2F</url>
    <content type="text"><![CDATA[简介RocketMQ是阿里巴巴开源的一款高性能、高吞吐率的分布式消息中间件。产品基于高可用分布式集群技术，提供消息发布订阅、消息轨迹查询、定时（延时）消息、资源统计、监控报警等功能，是阿里巴巴双11使用的核心产品。2016年阿里巴巴正式宣布将 RocketMQ 捐赠给 Apache 软件基金会。 RocketMQ的前身叫MetaQ，MetaQ从3.0版本开始更名为RocketMQ。 基本概念以下内容来自阿里云对MQ项目的介绍。 应用场景 异步解耦，基于发布订阅模型，对分布式应用进行异步解耦，增加应用的水平扩展能力； 削峰填谷，大促等流量洪流突然来袭时，MQ 可以缓冲突发流量，避免下游订阅系统因突发流量崩溃； 日志监控，作为重要日志的监控通信管道，将应用日志监控对系统性能影响降到最低； 消息推送，为社交应用和物联网应用提供点对点推送，一对多广播式推送的能力； 金融报文，发送金融报文，实现金融准实时的报文传输，可靠安全； 电信信令，将电信信令封装成消息，传递到各个控制终端，实现准实时控制和信息传递。 消息类型定时消息和延时消息 定时消息：Producer 将消息发送到 MQ 服务端，但并不期望这条消息立马投递，而是推迟到在当前时间点之后的某一个时间投递到 Consumer 进行消费。 延时消息：Producer 将消息发送到 MQ 服务端，但并不期望这条消息立马投递，而是延迟一定时间后才投递到 Consumer 进行消费。 定时/延时消息适用于如下一些场景： 消息生产和消费有时间窗口要求：比如在电商交易中超时未支付关闭订单的场景，在订单创建时会发送一条 MQ 延时消息，这条消息将会在30分钟以后投递给消费者，消费者收到此消息后需要判断对应的订单是否已完成支付。如支付未完成，则关闭订单，如已完成支付则忽略。 通过消息触发一些定时任务：比如在某一固定时间点向用户发送提醒消息。 顺序消息顺序消息是MQ提供的一种按照顺序进行发布和消费的消息类型。顺序消息由两个部分组成：顺序发布和顺序消费。顺序消息类型分为两种：全局顺序和分区顺序。 全局顺序消息 MQ全局顺序消息适用于以下场景：性能要求不高，所有的消息严格按照 FIFO 原则进行消息发布和消费的场景。 分区顺序消息 MQ 分区顺序消息适用于如下场景：性能要求高，以 sharding key 作为分区字段，在同一个区块中严格的按照 FIFO 原则进行消息发布和消费的场景。 举例说明：【例一】用户注册需要发送发验证码，以用户 ID 作为 sharding key， 那么同一个用户发送的消息都会按照先后顺序来发布和订阅。【例二】电商的订单创建，以订单 ID 作为 sharding key，那么同一个订单相关的创建订单消息、订单支付消息、订单退款消息、订单物流消息都会按照先后顺序来发布和订阅。 阿里巴巴集团内部电商系统均使用此种分区顺序消息，既保证业务的顺序，同时又能保证业务的高性能。 事务消息 事务消息：MQ 提供类似XA的分布事务功能，通过 MQ 事务消息能达到分布式事务的最终一致； 半消息：暂不能投递的消息，发送方已经将消息成功发送到了 MQ 服务端，但是服务端未收到生产者对该消息的二次确认，此时该消息被标记成“暂不能投递”状态，处于该种状态下的消息即半消息； 消息回查：由于网络闪断、生产者应用重启等原因，导致某条事务消息的二次确认丢失，MQ 服务端通过扫描发现某条消息长期处于“半消息”时，需要主动向消息生产者询问该消息的最终状态（Commit 或是 Rollback），该过程即消息回查。 如上图所示，事务消息的处理过程如下： 发送方向 MQ 服务端发送消息； MQ Server 将消息持久化成功之后，向发送方 ACK 确认消息已经发送成功，此时消息为半消息； 发送方开始执行本地事务逻辑； 发送方根据本地事务执行结果向 MQ Server 提交二次确认（Commit 或是 Rollback），MQ Server 收到 Commit 状态则将半消息标记为可投递，订阅方最终将收到该消息；MQ Server 收到 Rollback 状态则删除半消息，订阅方将不会接受该消息； 在断网或者是应用重启的特殊情况下，上述步骤4提交的二次确认最终未到达 MQ Server，经过固定时间后 MQ Server 将对该消息发起消息回查； 发送方收到消息回查后，需要检查对应消息的本地事务执行的最终结果； 发送方根据检查得到的本地事务的最终状态再次提交二次确认，MQ Server 仍按照步骤4对半消息进行操作。 事务消息完成本地事务后，可在返回如下三种状态： TransactionStatus.CommitTransaction 提交事务，允许订阅方消费该消息； TransactionStatus.RollbackTransaction 回滚事务，消息将被丢弃不允许消费； TransactionStatus.Unknow 暂时无法判断状态，期待固定时间以后 MQ Server 向发送方进行消息回查。 集群消费和广播消费集群消费 消息只被消费者组中的一个实例消费； 这是我们最常见的模式，集群消费可以很方便的横向拓展，提升处理能力。 广播消费 消费者组中的每一个实例都可以消费到消息。 消息过滤Tag，即消息标签、消息类型，用来区分某个 MQ 的 Topic 下的消息分类。MQ 允许消费者按照 Tag 对消息进行过滤，确保消费者最终只消费到他关心的消息类型。 以下图电商交易场景为例，从客户下单到收到商品这一过程会生产一系列消息，比如订单创建消息（order）、支付消息（pay）、物流消息（logistics）。这些消息会发送到 Topic 为 Trade_Topic 的队列中，被各个不同的系统所接收，比如支付系统、物流系统、交易成功率分析系统、实时计算系统等。其中，物流系统只需接收物流类型的消息（logistics），而实时计算系统需要接收所有和交易相关（order、pay、logistics）的消息。 说明：针对消息归类，您可以选择创建多个 Topic， 或者在同一个 Topic 下创建多个 Tag。但通常情况下，不同的 Topic 之间的消息没有必然的联系，而 Tag 则用来区分同一个 Topic 下相互关联的消息，比如全集和子集的关系，流程先后的关系。 消息重试 当消息不能送达时，MQ 默认允许每条消息最多重试 16 次，每次重试的间隔越来越长，从10 秒、30秒、1分钟，直到2小时； 如果消息重试 16 次后仍然失败，消息将不再投递； 也就是说，某条消息在一直消费失败的前提下，将会在接下来的 4 小时 46 分钟之内进行 16 次重试，超过这个时间范围消息将不再重试投递。 消费幂等发送时消息重复（消息 Message ID 不同） MQ Producer 发送消息场景下，消息已成功发送到服务端并完成持久化，此时网络闪断或者客户端宕机导致服务端应答给客户端失败。如果此时 MQ Producer 意识到消息发送失败并尝试再次发送消息，MQ 消费者后续会收到两条内容相同但是 Message ID 不同的消息。 投递时消息重复（消息 Message ID 相同） MQ Consumer 消费消息场景下，消息已投递到消费者并完成业务处理，当客户端给服务端反馈应答的时候网络闪断。为了保证消息至少被消费一次，MQ 服务端将在网络恢复后再次尝试投递之前已被处理过的消息，MQ 消费者后续会收到两条内容相同并且 Message ID 也相同的消息。 真正安全的幂等处理，不建议以 Message ID 作为处理依据。最好的方式是以业务唯一标识作为幂等处理的关键依据，而业务的唯一标识可以通过消息 Key 进行设置。 消息发送方式 可靠同步发送，同步发送是指消息发送方发出数据后，会在收到接收方发回响应之后才发下一个数据包的通讯方式； 可靠异步发送，异步发送是指发送方发出数据后，不等接收方发回响应，接着发送下个数据包的通讯方式。MQ 的异步发送，需要用户实现异步发送回调接口（SendCallback），在执行消息的异步发送时，应用不需要等待服务器响应即可直接返回，通过回调接口接收服务器响应，并对服务器的响应结果进行处理； 单向（Oneway）发送，单向（Oneway）发送特点为只负责发送消息，不等待服务器回应且没有回调函数触发，即只发送请求不等待应答。此方式发送消息的过程耗时非常短，一般在微秒级别。]]></content>
      <categories>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>mq</tag>
        <tag>rocketmq</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Hexo搭建自己的博客]]></title>
    <url>%2F2018%2F04%2F21%2Fhexo-intro%2F</url>
    <content type="text"><![CDATA[概述搭建个性化的博客网站，我们需要用到hexo和github。其中Hexo是一个快速、简洁且高效的博客框架，使用hexo我们可以快速编写、生成、预览和部署博客文章，最终我们的博客文章发布到github上。Github为个人博客提供了免费的发布平台，通过域名yourname.github.io可以访问到同名的github项目。 准备工作安装Git可以去这里下载Git的windows版本，正确安装后可以在Shell中查看到git版本 $ git --versiongit version 2.7.2.windows.1 安装Node.js去nodejs官网下载最新版本(node-v8.11.1-x64.msi)并安装，正确安装后可以查看到版本 $ node -vv8.11.1 安装Hexonode.js中带了包管理工具npm，后面的模块都可以通过npm来安装，-g表示全局安装 官网上的文档中只安装了hexo-cli，试了一下有问题，这里还是安装hexo(里面包含hexo-cli) $ npm install -g hexo$ hexo versionhexo: 3.7.1hexo-cli: 1.1.0 创建Github项目 注册github账户，并做好配置 创建以用户开头，以github.io结尾的项目，例如：我的用户名是waterlu，那么创建的项目名称为 waterlu.github.io 项目创建成功后访问 https://waterlu.github.io/ ，后面就是部署页面的操作了。 Hexo基本操作Hexo是静态化的博客框架，使用markdown格式编写文章，然后通过hexo generate指令生成静态的HTML页面，最后通过hexo depoly指令将HTML页面上传到GitHub上。 所有hexo操作都需要在hexo init的目录执行，也就是含有_config.yml和source的目录，在其他目录执行hexo generate等操作是无效的。 初始化 hexo init 指令创建新的博客 $ cd /c/lu/blog$ hexo init$ ls -l-rw-r--r-- 1 _config.ymldrwxr-xr-x 1 node_modules/-rw-r--r-- 1 package.jsondrwxr-xr-x 1 scaffolds/drwxr-xr-x 1 source/drwxr-xr-x 1 themes/ 配置_config.yml，配置个性化信息和部署地址 title: Waterlu&apos;s Blogdescription: 个人技术博客author: Water Ludeploy: type: git repo: git@github.com:waterlu/waterlu.github.io.git branch: master 生成网站$ hexo generate 本地预览 启动web服务 访问http://localhost:4000 $ hexo server 部署到Github 第一次部署前安装hexo-deployer-git 以后通过deploy部署（事先需要在_config.yml中配置github相关信息） $ npm install hexo-deployer-git --save$ hexo deploy 个性化定制主题我使用的主题是Maupassant，感觉比较简洁。 注意：npm install的两个模块不是全局安装的，每次hexo init创建新项目后都得执行(npm install -g才是全局安装)。 $ git clone https://github.com/tufu9441/maupassant-hexo.git themes/maupassant$ npm install hexo-renderer-pug --save$ npm install hexo-renderer-sass --save 修改根目录下的_config.yml，设置theme为maupassant theme: maupassant 创建about页面 $ hexo new page about 修改themes/maupassant目录下的_config.yml，去掉RSS页面 menu: - page: home directory: . icon: fa-home - page: archive directory: archives/ icon: fa-archive - page: about directory: about/ icon: fa-user # - page: rss # directory: atom.xml # icon: fa-rss 评论功能 TODO 站内搜索 安装hexo-generator-search $ npm install hexo-generator-search --save$ npm install hexo-generator-searchdb --save 修改根目录下的_config.yml，增加如下配置 search: path: search.xml field: post format: html limit: 10000 修改themes\maupassant下的_config.yml，打开self_search google_search: false ## Use Google search, true/false.baidu_search: false ## Use Baidu search, true/false.swiftype: ## Your swiftype_key, e.g. m7b11ZrsT8Me7gzApciTtinysou: ## Your tinysou_key, e.g. 4ac092ad8d749fdc6293self_search: true ## Use a jQuery-based local search engine, true/false. 访问统计 修改themes\maupassant下的_config.yml，打开不蒜子busuanzi: true ## If you want to use Busuanzi page views please set the value to true. 流程图和序列图Hexo默认不支持markdown的flow图和sequence图，需要安装插件 进入项目根目录安装插件 $ npm install --save hexo-filter-flowchart$ npm install --save hexo-filter-sequence 修改项目的_config.yml，增加配置 flowchart: # raphael: # optional, the source url of raphael.js # flowchart: # optional, the source url of flowchart.js options: # options used for `drawSVG`sequence: # webfont: # optional, the source url of webfontloader.js # snap: # optional, the source url of snap.svg.js # underscore: # optional, the source url of underscore.js # sequence: # optional, the source url of sequence-diagram.js # css: # optional, the url for css, such as hand drawn theme options: theme: css_class: Hexo日常操作写文章 [layout]默认为post，指的是文章的布局类型，在_config.yml中可以配置 如果[layout]=post，那么新文章将生成到source/_posts目录下 $ hexo new [layout] &lt;title&gt; 文章开头”—“之间的部分称为Front-matter，主要包括以下信息 参数 描述 layout 文章布局 title 文章标题 date 文章发布时间 updated 文章更新时间 tags 标签 categories 分类 发表文章$ hexo new post [title]$ hexo clean$ hexo generate$ hexo server$ hexo deploy 常见问题解析错误 当title.md文章中出现无法解析的markdown语法时，报错Template render error 因为需要把markdown转成html，所以必须解析正确 $ hexo gINFO Start processingFATAL Something's wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.htmlTemplate render error: expected variable end]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
</search>
